{"ast":null,"code":"import { ignoreFocusEvent as $8a9cb279dc87e130$export$fda7da73ab5d4c48 } from \"./utils.mjs\";\nimport { isMac as $28AnR$isMac, isVirtualClick as $28AnR$isVirtualClick, getOwnerWindow as $28AnR$getOwnerWindow, getOwnerDocument as $28AnR$getOwnerDocument } from \"@react-aria/utils\";\nimport { useState as $28AnR$useState, useEffect as $28AnR$useEffect } from \"react\";\nimport { useIsSSR as $28AnR$useIsSSR } from \"@react-aria/ssr\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$export$d90243b58daecda7 = new Map(); // We use a map here to support setting event listeners across multiple document objects.\n\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false; // Only Tab or Esc keys will make focus visible on text input elements\n\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\n\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\n\n\nfunction $507fabe10e71c6fb$var$isValidKey(e) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || !(0, $28AnR$isMac)() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\n\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n\n  if ($507fabe10e71c6fb$var$isValidKey(e)) {\n    $507fabe10e71c6fb$var$currentModality = 'keyboard';\n    $507fabe10e71c6fb$var$triggerChangeHandlers('keyboard', e);\n  }\n}\n\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n  $507fabe10e71c6fb$var$currentModality = 'pointer';\n\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$triggerChangeHandlers('pointer', e);\n  }\n}\n\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n  if ((0, $28AnR$isVirtualClick)(e)) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    $507fabe10e71c6fb$var$currentModality = 'virtual';\n  }\n}\n\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document || (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) || !e.isTrusted) return; // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n\n  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n    $507fabe10e71c6fb$var$currentModality = 'virtual';\n    $507fabe10e71c6fb$var$triggerChangeHandlers('virtual', e);\n  }\n\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\n\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n  if (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) return; // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\n\n\nfunction $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {\n  if (typeof window === 'undefined' || typeof document === 'undefined' || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $28AnR$getOwnerWindow)(element))) return;\n  const windowObject = (0, $28AnR$getOwnerWindow)(element);\n  const documentObject = (0, $28AnR$getOwnerDocument)(element); // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n\n  let focus = windowObject.HTMLElement.prototype.focus;\n\n  windowObject.HTMLElement.prototype.focus = function () {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    focus.apply(this, arguments);\n  };\n\n  documentObject.addEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.addEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true); // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n\n  windowObject.addEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.addEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.addEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.addEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.addEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } // Add unmount handler\n\n\n  windowObject.addEventListener('beforeunload', () => {\n    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);\n  }, {\n    once: true\n  });\n  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {\n    focus: focus\n  });\n}\n\nconst $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {\n  const windowObject = (0, $28AnR$getOwnerWindow)(element);\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  if (loadListener) documentObject.removeEventListener('DOMContentLoaded', loadListener);\n  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;\n  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;\n  documentObject.removeEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n  documentObject.removeEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);\n  windowObject.removeEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n  windowObject.removeEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.removeEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.removeEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    documentObject.removeEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n  }\n\n  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);\n};\n\nfunction $507fabe10e71c6fb$export$2f1888112f558a7d(element) {\n  const documentObject = (0, $28AnR$getOwnerDocument)(element);\n  let loadListener;\n  if (documentObject.readyState !== 'loading') $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);else {\n    loadListener = () => {\n      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n    };\n\n    documentObject.addEventListener('DOMContentLoaded', loadListener);\n  }\n  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);\n} // Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\n\n\nif (typeof document !== 'undefined') $507fabe10e71c6fb$export$2f1888112f558a7d();\n\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n  return $507fabe10e71c6fb$var$currentModality !== 'pointer';\n}\n\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n  return $507fabe10e71c6fb$var$currentModality;\n}\n\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n  $507fabe10e71c6fb$var$currentModality = modality;\n  $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\n\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  let [modality, setModality] = (0, $28AnR$useState)($507fabe10e71c6fb$var$currentModality);\n  (0, $28AnR$useEffect)(() => {\n    let handler = () => {\n      setModality($507fabe10e71c6fb$var$currentModality);\n    };\n\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n  }, []);\n  return (0, $28AnR$useIsSSR)() ? null : modality;\n}\n\nconst $507fabe10e71c6fb$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\n\nfunction $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n  let document1 = (0, $28AnR$getOwnerDocument)(e === null || e === void 0 ? void 0 : e.target);\n  const IHTMLInputElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== 'undefined' ? (0, $28AnR$getOwnerWindow)(e === null || e === void 0 ? void 0 : e.target).KeyboardEvent : KeyboardEvent; // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)\n  // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element\n\n  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;\n  return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\n\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6() {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    isTextInput: isTextInput,\n    autoFocus: autoFocus\n  } = props;\n  let [isFocusVisibleState, setFocusVisible] = (0, $28AnR$useState)(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n  $507fabe10e71c6fb$export$ec71b4b83ac08ec3(isFocusVisible => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {\n    isTextInput: isTextInput\n  });\n  return {\n    isFocusVisible: isFocusVisibleState\n  };\n}\n\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n  (0, $28AnR$useEffect)(() => {\n    let handler = (modality, e) => {\n      // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape\n      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e)) return;\n      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n    };\n\n    $507fabe10e71c6fb$var$changeHandlers.add(handler);\n    return () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n\nexport { $507fabe10e71c6fb$export$d90243b58daecda7 as hasSetupGlobalListeners, $507fabe10e71c6fb$export$2f1888112f558a7d as addWindowFocusTracking, $507fabe10e71c6fb$export$b9b3dfddab17db27 as isFocusVisible, $507fabe10e71c6fb$export$630ff653c5ada6a9 as getInteractionModality, $507fabe10e71c6fb$export$8397ddfc504fdb9a as setInteractionModality, $507fabe10e71c6fb$export$98e20ec92f614cfe as useInteractionModality, $507fabe10e71c6fb$export$ffd9e5021c1fb2d6 as useFocusVisible, $507fabe10e71c6fb$export$ec71b4b83ac08ec3 as useFocusVisibleListener };","map":{"version":3,"mappings":"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","names":["$507fabe10e71c6fb$var$currentModality","$507fabe10e71c6fb$var$changeHandlers","Set","$507fabe10e71c6fb$export$d90243b58daecda7","Map","$507fabe10e71c6fb$var$hasEventBeforeFocus","$507fabe10e71c6fb$var$hasBlurredWindowRecently","$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS","Tab","Escape","$507fabe10e71c6fb$var$triggerChangeHandlers","modality","e","handler","$507fabe10e71c6fb$var$isValidKey","metaKey","altKey","ctrlKey","key","$507fabe10e71c6fb$var$handleKeyboardEvent","$507fabe10e71c6fb$var$handlePointerEvent","type","$507fabe10e71c6fb$var$handleClickEvent","$507fabe10e71c6fb$var$handleFocusEvent","target","window","document","isTrusted","$507fabe10e71c6fb$var$handleWindowBlur","$507fabe10e71c6fb$var$setupGlobalFocusEvents","element","get","windowObject","documentObject","focus","HTMLElement","prototype","apply","arguments","addEventListener","PointerEvent","process","env","NODE_ENV","$507fabe10e71c6fb$var$tearDownWindowFocusTracking","once","set","loadListener","removeEventListener","has","delete","$507fabe10e71c6fb$export$2f1888112f558a7d","readyState","$507fabe10e71c6fb$export$b9b3dfddab17db27","$507fabe10e71c6fb$export$630ff653c5ada6a9","$507fabe10e71c6fb$export$8397ddfc504fdb9a","$507fabe10e71c6fb$export$98e20ec92f614cfe","setModality","add","$507fabe10e71c6fb$var$nonTextInputTypes","$507fabe10e71c6fb$var$isKeyboardFocusEvent","isTextInput","document1","IHTMLInputElement","HTMLInputElement","IHTMLTextAreaElement","HTMLTextAreaElement","IHTMLElement","IKeyboardEvent","KeyboardEvent","activeElement","isContentEditable","$507fabe10e71c6fb$export$ffd9e5021c1fb2d6","props","autoFocus","isFocusVisibleState","setFocusVisible","$507fabe10e71c6fb$export$ec71b4b83ac08ec3","isFocusVisible","fn","deps","opts"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\useFocusVisible.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, getOwnerWindow, isMac, isVirtualClick} from '@react-aria/utils';\nimport {ignoreFocusEvent} from './utils';\nimport {useEffect, useState} from 'react';\nimport {useIsSSR} from '@react-aria/ssr';\n\nexport type Modality = 'keyboard' | 'pointer' | 'virtual';\ntype HandlerEvent = PointerEvent | MouseEvent | KeyboardEvent | FocusEvent | null;\ntype Handler = (modality: Modality, e: HandlerEvent) => void;\nexport type FocusVisibleHandler = (isFocusVisible: boolean) => void;\nexport interface FocusVisibleProps {\n  /** Whether the element is a text input. */\n  isTextInput?: boolean,\n  /** Whether the element will be auto focused. */\n  autoFocus?: boolean\n}\n\nexport interface FocusVisibleResult {\n  /** Whether keyboard focus is visible globally. */\n  isFocusVisible: boolean\n}\n\nlet currentModality: null | Modality = null;\nlet changeHandlers = new Set<Handler>();\ninterface GlobalListenerData {\n  focus: () => void\n}\nexport let hasSetupGlobalListeners = new Map<Window, GlobalListenerData>(); // We use a map here to support setting event listeners across multiple document objects.\nlet hasEventBeforeFocus = false;\nlet hasBlurredWindowRecently = false;\n\n// Only Tab or Esc keys will make focus visible on text input elements\nconst FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\n\nfunction triggerChangeHandlers(modality: Modality, e: HandlerEvent) {\n  for (let handler of changeHandlers) {\n    handler(modality, e);\n  }\n}\n\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction isValidKey(e: KeyboardEvent) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || (!isMac() && e.altKey) || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\n\n\nfunction handleKeyboardEvent(e: KeyboardEvent) {\n  hasEventBeforeFocus = true;\n  if (isValidKey(e)) {\n    currentModality = 'keyboard';\n    triggerChangeHandlers('keyboard', e);\n  }\n}\n\nfunction handlePointerEvent(e: PointerEvent | MouseEvent) {\n  currentModality = 'pointer';\n  if (e.type === 'mousedown' || e.type === 'pointerdown') {\n    hasEventBeforeFocus = true;\n    triggerChangeHandlers('pointer', e);\n  }\n}\n\nfunction handleClickEvent(e: MouseEvent) {\n  if (isVirtualClick(e)) {\n    hasEventBeforeFocus = true;\n    currentModality = 'virtual';\n  }\n}\n\nfunction handleFocusEvent(e: FocusEvent) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document || ignoreFocusEvent || !e.isTrusted) {\n    return;\n  }\n\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {\n    currentModality = 'virtual';\n    triggerChangeHandlers('virtual', e);\n  }\n\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = false;\n}\n\nfunction handleWindowBlur() {\n  if (ignoreFocusEvent) {\n    return;\n  }\n\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  hasEventBeforeFocus = false;\n  hasBlurredWindowRecently = true;\n}\n\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction setupGlobalFocusEvents(element?: HTMLElement | null) {\n  if (typeof window === 'undefined' || typeof document === 'undefined' || hasSetupGlobalListeners.get(getOwnerWindow(element))) {\n    return;\n  }\n\n  const windowObject = getOwnerWindow(element);\n  const documentObject = getOwnerDocument(element);\n\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function () {\n    hasEventBeforeFocus = true;\n    focus.apply(this, arguments as unknown as [options?: FocusOptions | undefined]);\n  };\n\n  documentObject.addEventListener('keydown', handleKeyboardEvent, true);\n  documentObject.addEventListener('keyup', handleKeyboardEvent, true);\n  documentObject.addEventListener('click', handleClickEvent, true);\n\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  windowObject.addEventListener('focus', handleFocusEvent, true);\n  windowObject.addEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.addEventListener('pointerdown', handlePointerEvent, true);\n    documentObject.addEventListener('pointermove', handlePointerEvent, true);\n    documentObject.addEventListener('pointerup', handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.addEventListener('mousedown', handlePointerEvent, true);\n    documentObject.addEventListener('mousemove', handlePointerEvent, true);\n    documentObject.addEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  // Add unmount handler\n  windowObject.addEventListener('beforeunload', () => {\n    tearDownWindowFocusTracking(element);\n  }, {once: true});\n\n  hasSetupGlobalListeners.set(windowObject, {focus});\n}\n\nconst tearDownWindowFocusTracking = (element, loadListener?: () => void) => {\n  const windowObject = getOwnerWindow(element);\n  const documentObject = getOwnerDocument(element);\n  if (loadListener) {\n    documentObject.removeEventListener('DOMContentLoaded', loadListener);\n  }\n  if (!hasSetupGlobalListeners.has(windowObject)) {\n    return;\n  }\n  windowObject.HTMLElement.prototype.focus = hasSetupGlobalListeners.get(windowObject)!.focus;\n\n  documentObject.removeEventListener('keydown', handleKeyboardEvent, true);\n  documentObject.removeEventListener('keyup', handleKeyboardEvent, true);\n  documentObject.removeEventListener('click', handleClickEvent, true);\n\n  windowObject.removeEventListener('focus', handleFocusEvent, true);\n  windowObject.removeEventListener('blur', handleWindowBlur, false);\n\n  if (typeof PointerEvent !== 'undefined') {\n    documentObject.removeEventListener('pointerdown', handlePointerEvent, true);\n    documentObject.removeEventListener('pointermove', handlePointerEvent, true);\n    documentObject.removeEventListener('pointerup', handlePointerEvent, true);\n  } else if (process.env.NODE_ENV === 'test') {\n    documentObject.removeEventListener('mousedown', handlePointerEvent, true);\n    documentObject.removeEventListener('mousemove', handlePointerEvent, true);\n    documentObject.removeEventListener('mouseup', handlePointerEvent, true);\n  }\n\n  hasSetupGlobalListeners.delete(windowObject);\n};\n\n/**\n * EXPERIMENTAL\n * Adds a window (i.e. iframe) to the list of windows that are being tracked for focus visible.\n *\n * Sometimes apps render portions of their tree into an iframe. In this case, we cannot accurately track if the focus\n * is visible because we cannot see interactions inside the iframe. If you have this in your application's architecture,\n * then this function will attach event listeners inside the iframe. You should call `addWindowFocusTracking` with an\n * element from inside the window you wish to add. We'll retrieve the relevant elements based on that.\n * Note, you do not need to call this for the default window, as we call it for you.\n *\n * When you are ready to stop listening, but you do not wish to unmount the iframe, you may call the cleanup function\n * returned by `addWindowFocusTracking`. Otherwise, when you unmount the iframe, all listeners and state will be cleaned\n * up automatically for you.\n *\n * @param element @default document.body - The element provided will be used to get the window to add.\n * @returns A function to remove the event listeners and cleanup the state.\n */\nexport function addWindowFocusTracking(element?: HTMLElement | null): () => void {\n  const documentObject = getOwnerDocument(element);\n  let loadListener;\n  if (documentObject.readyState !== 'loading') {\n    setupGlobalFocusEvents(element);\n  } else {\n    loadListener = () => {\n      setupGlobalFocusEvents(element);\n    };\n    documentObject.addEventListener('DOMContentLoaded', loadListener);\n  }\n\n  return () => tearDownWindowFocusTracking(element, loadListener);\n}\n\n// Server-side rendering does not have the document object defined\n// eslint-disable-next-line no-restricted-globals\nif (typeof document !== 'undefined') {\n  addWindowFocusTracking();\n}\n\n/**\n * If true, keyboard focus is visible.\n */\nexport function isFocusVisible(): boolean {\n  return currentModality !== 'pointer';\n}\n\nexport function getInteractionModality(): Modality | null {\n  return currentModality;\n}\n\nexport function setInteractionModality(modality: Modality): void {\n  currentModality = modality;\n  triggerChangeHandlers(modality, null);\n}\n\n/**\n * Keeps state of the current modality.\n */\nexport function useInteractionModality(): Modality | null {\n  setupGlobalFocusEvents();\n\n  let [modality, setModality] = useState(currentModality);\n  useEffect(() => {\n    let handler = () => {\n      setModality(currentModality);\n    };\n\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  }, []);\n\n  return useIsSSR() ? null : modality;\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction isKeyboardFocusEvent(isTextInput: boolean, modality: Modality, e: HandlerEvent) {\n  let document = getOwnerDocument(e?.target as Element);\n  const IHTMLInputElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLInputElement : HTMLInputElement;\n  const IHTMLTextAreaElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLTextAreaElement : HTMLTextAreaElement;\n  const IHTMLElement = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).HTMLElement : HTMLElement;\n  const IKeyboardEvent = typeof window !== 'undefined' ? getOwnerWindow(e?.target as Element).KeyboardEvent : KeyboardEvent;\n\n  // For keyboard events that occur on a non-input element that will move focus into input element (aka ArrowLeft going from Datepicker button to the main input group)\n  // we need to rely on the user passing isTextInput into here. This way we can skip toggling focus visiblity for said input element\n  isTextInput = isTextInput ||\n    (document.activeElement instanceof IHTMLInputElement && !nonTextInputTypes.has(document.activeElement.type)) ||\n    document.activeElement instanceof IHTMLTextAreaElement ||\n    (document.activeElement instanceof IHTMLElement && document.activeElement.isContentEditable);\n  return !(isTextInput && modality === 'keyboard' && e instanceof IKeyboardEvent && !FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\n\n/**\n * Manages focus visible state for the page, and subscribes individual components for updates.\n */\nexport function useFocusVisible(props: FocusVisibleProps = {}): FocusVisibleResult {\n  let {isTextInput, autoFocus} = props;\n  let [isFocusVisibleState, setFocusVisible] = useState(autoFocus || isFocusVisible());\n  useFocusVisibleListener((isFocusVisible) => {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {isTextInput});\n\n  return {isFocusVisible: isFocusVisibleState};\n}\n\n/**\n * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).\n */\nexport function useFocusVisibleListener(fn: FocusVisibleHandler, deps: ReadonlyArray<any>, opts?: {isTextInput?: boolean}): void {\n  setupGlobalFocusEvents();\n\n  useEffect(() => {\n    let handler = (modality: Modality, e: HandlerEvent) => {\n      // We want to early return for any keyboard events that occur inside text inputs EXCEPT for Tab and Escape\n      if (!isKeyboardFocusEvent(!!(opts?.isTextInput), modality, e)) {\n        return;\n      }\n      fn(isFocusVisible());\n    };\n    changeHandlers.add(handler);\n    return () => {\n      changeHandlers.delete(handler);\n    };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n"]},"metadata":{},"sourceType":"module"}
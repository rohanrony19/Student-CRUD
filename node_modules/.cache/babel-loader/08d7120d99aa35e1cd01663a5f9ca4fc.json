{"ast":null,"code":"import { useLayoutEffect as $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c } from \"./useLayoutEffect.mjs\";\nimport { flushSync as $jJMAe$flushSync } from \"react-dom\";\nimport { useState as $jJMAe$useState, useCallback as $jJMAe$useCallback } from \"react\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $d3f049242431219c$export$6d3443f2c48bfc20(ref) {\n  let isReady = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let [isEntering, setEntering] = (0, $jJMAe$useState)(true);\n  let isAnimationReady = isEntering && isReady; // There are two cases for entry animations:\n  // 1. CSS @keyframes. The `animation` property is set during the isEntering state, and it is removed after the animation finishes.\n  // 2. CSS transitions. The initial styles are applied during the isEntering state, and removed immediately, causing the transition to occur.\n  //\n  // In the second case, cancel any transitions that were triggered prior to the isEntering = false state (when the transition is supposed to start).\n  // This can happen when isReady starts as false (e.g. popovers prior to placement calculation).\n\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    if (isAnimationReady && ref.current && 'getAnimations' in ref.current) {\n      for (let animation of ref.current.getAnimations()) if (animation instanceof CSSTransition) animation.cancel();\n    }\n  }, [ref, isAnimationReady]);\n  $d3f049242431219c$var$useAnimation(ref, isAnimationReady, (0, $jJMAe$useCallback)(() => setEntering(false), []));\n  return isAnimationReady;\n}\n\nfunction $d3f049242431219c$export$45fda7c47f93fd48(ref, isOpen) {\n  let [exitState, setExitState] = (0, $jJMAe$useState)(isOpen ? 'open' : 'closed');\n\n  switch (exitState) {\n    case 'open':\n      // If isOpen becomes false, set the state to exiting.\n      if (!isOpen) setExitState('exiting');\n      break;\n\n    case 'closed':\n    case 'exiting':\n      // If we are exiting and isOpen becomes true, the animation was interrupted.\n      // Reset the state to open.\n      if (isOpen) setExitState('open');\n      break;\n  }\n\n  let isExiting = exitState === 'exiting';\n  $d3f049242431219c$var$useAnimation(ref, isExiting, (0, $jJMAe$useCallback)(() => {\n    // Set the state to closed, which will cause the element to be unmounted.\n    setExitState(state => state === 'exiting' ? 'closed' : state);\n  }, []));\n  return isExiting;\n}\n\nfunction $d3f049242431219c$var$useAnimation(ref, isActive, onEnd) {\n  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c)(() => {\n    if (isActive && ref.current) {\n      if (!('getAnimations' in ref.current)) {\n        // JSDOM\n        onEnd();\n        return;\n      }\n\n      let animations = ref.current.getAnimations();\n\n      if (animations.length === 0) {\n        onEnd();\n        return;\n      }\n\n      let canceled = false;\n      Promise.all(animations.map(a => a.finished)).then(() => {\n        if (!canceled) (0, $jJMAe$flushSync)(() => {\n          onEnd();\n        });\n      }).catch(() => {});\n      return () => {\n        canceled = true;\n      };\n    }\n  }, [ref, isActive, onEnd]);\n}\n\nexport { $d3f049242431219c$export$6d3443f2c48bfc20 as useEnterAnimation, $d3f049242431219c$export$45fda7c47f93fd48 as useExitAnimation };","map":{"version":3,"mappings":";;;AAAA;;;;;;;;;;;;AAgBO,SAASA,yCAAT,CAA2BC,GAA3B,EAAsF;EAAA,IAAvBC,OAAuB,uEAAJ,IAAI;EAC3F,IAAI,CAACC,UAAD,EAAaC,WAAb,IAA4B,qBAAS,IAAT,CAAhC;EACA,IAAIC,mBAAmBF,cAAcD,OAArC,CAF2F,CAI3F;EACA;EACA;EACA;EACA;EACA;;EACA,+CAAgB;IACd,IAAIG,oBAAoBJ,IAAIK,OAAxB,IAAmC,mBAAmBL,IAAIK,OAA9D,EAAuE;MACrE,KAAK,IAAIC,SAAT,IAAsBN,IAAIK,OAAJ,CAAYE,aAAZ,EAAtB,EACE,IAAID,qBAAqBE,aAAzB,EACEF,UAAUG,MAAV;IAGN;EACF,CARA,EAQG,CAACT,GAAD,EAAMI,gBAAN,CARH;EAUAM,mCAAaV,GAAb,EAAkBI,gBAAlB,EAAoC,wBAAY,MAAMD,YAAY,KAAZ,CAAlB,EAAsC,EAAtC,CAApC;EACA,OAAOC,gBAAP;AACF;;AAEO,SAASO,yCAAT,CAA0BX,GAA1B,EAA8DY,MAA9D,EAA6E;EAClF,IAAI,CAACC,SAAD,EAAYC,YAAZ,IAA4B,qBAAwCF,SAAS,MAAT,GAAkB,QAA1D,CAAhC;;EAEA,QAAQC,SAAR;IACE,KAAK,MAAL;MACE;MACA,IAAI,CAACD,MAAL,EACEE,aAAa,SAAb;MAEF;;IACF,KAAK,QAAL;IACA,KAAK,SAAL;MACE;MACA;MACA,IAAIF,MAAJ,EACEE,aAAa,MAAb;MAEF;EAdJ;;EAiBA,IAAIC,YAAYF,cAAc,SAA9B;EACAH,mCACEV,GADF,EAEEe,SAFF,EAGE,wBAAY;IACV;IACAD,aAAaE,SAASA,UAAU,SAAV,GAAsB,QAAtB,GAAiCA,KAAvD;EACF,CAHA,EAGG,EAHH,CAHF;EASA,OAAOD,SAAP;AACF;;AAEA,SAASL,kCAAT,CAAsBV,GAAtB,EAA0DiB,QAA1D,EAA6EC,KAA7E,EAA8F;EAC5F,+CAAgB;IACd,IAAID,YAAYjB,IAAIK,OAApB,EAA6B;MAC3B,IAAI,EAAE,mBAAmBL,IAAIK,OAAzB,CAAJ,EAAuC;QACrC;QACAa;QACA;MACF;;MAEA,IAAIC,aAAanB,IAAIK,OAAJ,CAAYE,aAAZ,EAAjB;;MACA,IAAIY,WAAWC,MAAX,KAAsB,CAA1B,EAA6B;QAC3BF;QACA;MACF;;MAEA,IAAIG,WAAW,KAAf;MACAC,QAAQC,GAAR,CAAYJ,WAAWK,GAAX,CAAeC,KAAKA,EAAEC,QAAtB,CAAZ,EAA6CC,IAA7C,CAAkD;QAChD,IAAI,CAACN,QAAL,EACE,sBAAU;UACRH;QACF,CAFA;MAIJ,CANA,EAMGU,KANH,CAMS,OAAO,CANhB;MAQA,OAAO;QACLP,WAAW,IAAX;MACF,CAFA;IAGF;EACF,CA3BA,EA2BG,CAACrB,GAAD,EAAMiB,QAAN,EAAgBC,KAAhB,CA3BH;AA4BF","names":["$d3f049242431219c$export$6d3443f2c48bfc20","ref","isReady","isEntering","setEntering","isAnimationReady","current","animation","getAnimations","CSSTransition","cancel","$d3f049242431219c$var$useAnimation","$d3f049242431219c$export$45fda7c47f93fd48","isOpen","exitState","setExitState","isExiting","state","isActive","onEnd","animations","length","canceled","Promise","all","map","a","finished","then","catch"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\animation.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {flushSync} from 'react-dom';\nimport {RefObject, useCallback, useState} from 'react';\nimport {useLayoutEffect} from './useLayoutEffect';\n\nexport function useEnterAnimation(ref: RefObject<HTMLElement | null>, isReady: boolean = true): boolean {\n  let [isEntering, setEntering] = useState(true);\n  let isAnimationReady = isEntering && isReady;\n\n  // There are two cases for entry animations:\n  // 1. CSS @keyframes. The `animation` property is set during the isEntering state, and it is removed after the animation finishes.\n  // 2. CSS transitions. The initial styles are applied during the isEntering state, and removed immediately, causing the transition to occur.\n  //\n  // In the second case, cancel any transitions that were triggered prior to the isEntering = false state (when the transition is supposed to start).\n  // This can happen when isReady starts as false (e.g. popovers prior to placement calculation).\n  useLayoutEffect(() => {\n    if (isAnimationReady && ref.current && 'getAnimations' in ref.current) {\n      for (let animation of ref.current.getAnimations()) {\n        if (animation instanceof CSSTransition) {\n          animation.cancel();\n        }\n      }\n    }\n  }, [ref, isAnimationReady]);\n\n  useAnimation(ref, isAnimationReady, useCallback(() => setEntering(false), []));\n  return isAnimationReady;\n}\n\nexport function useExitAnimation(ref: RefObject<HTMLElement | null>, isOpen: boolean): boolean {\n  let [exitState, setExitState] = useState<'closed' | 'open' | 'exiting'>(isOpen ? 'open' : 'closed');\n\n  switch (exitState) {\n    case 'open':\n      // If isOpen becomes false, set the state to exiting.\n      if (!isOpen) {\n        setExitState('exiting');\n      }\n      break;\n    case 'closed':\n    case 'exiting':\n      // If we are exiting and isOpen becomes true, the animation was interrupted.\n      // Reset the state to open.\n      if (isOpen) {\n        setExitState('open');\n      }\n      break;\n  }\n\n  let isExiting = exitState === 'exiting';\n  useAnimation(\n    ref,\n    isExiting,\n    useCallback(() => {\n      // Set the state to closed, which will cause the element to be unmounted.\n      setExitState(state => state === 'exiting' ? 'closed' : state);\n    }, [])\n  );\n\n  return isExiting;\n}\n\nfunction useAnimation(ref: RefObject<HTMLElement | null>, isActive: boolean, onEnd: () => void): void {\n  useLayoutEffect(() => {\n    if (isActive && ref.current) {\n      if (!('getAnimations' in ref.current)) {\n        // JSDOM\n        onEnd();\n        return;\n      }\n\n      let animations = ref.current.getAnimations();\n      if (animations.length === 0) {\n        onEnd();\n        return;\n      }\n\n      let canceled = false;\n      Promise.all(animations.map(a => a.finished)).then(() => {\n        if (!canceled) {\n          flushSync(() => {\n            onEnd();\n          });\n        }\n      }).catch(() => {});\n\n      return () => {\n        canceled = true;\n      };\n    }\n  }, [ref, isActive, onEnd]);\n}\n"]},"metadata":{},"sourceType":"module"}
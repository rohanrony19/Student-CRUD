{"ast":null,"code":"import { createSyntheticEvent as $8a9cb279dc87e130$export$525bc4921d56d4a, preventFocus as $8a9cb279dc87e130$export$cabe61c495ee3649, setEventTarget as $8a9cb279dc87e130$export$c2b7abe5d61ec696 } from \"./utils.mjs\";\nimport { disableTextSelection as $14c0b72509d70225$export$16a4697467175487, restoreTextSelection as $14c0b72509d70225$export$b0d6fa1ab32e3295 } from \"./textSelection.mjs\";\nimport { PressResponderContext as $ae1eeba8b9eafd08$export$5165eccb35aaadb5 } from \"./context.mjs\";\nimport { _ as $7mdmh$_ } from \"@swc/helpers/_/_class_private_field_get\";\nimport { _ as $7mdmh$_1 } from \"@swc/helpers/_/_class_private_field_init\";\nimport { _ as $7mdmh$_2 } from \"@swc/helpers/_/_class_private_field_set\";\nimport { mergeProps as $7mdmh$mergeProps, useSyncRef as $7mdmh$useSyncRef, useGlobalListeners as $7mdmh$useGlobalListeners, useEffectEvent as $7mdmh$useEffectEvent, nodeContains as $7mdmh$nodeContains, getEventTarget as $7mdmh$getEventTarget, getOwnerDocument as $7mdmh$getOwnerDocument, chain as $7mdmh$chain, isMac as $7mdmh$isMac, openLink as $7mdmh$openLink, isVirtualClick as $7mdmh$isVirtualClick, isVirtualPointerEvent as $7mdmh$isVirtualPointerEvent, focusWithoutScrolling as $7mdmh$focusWithoutScrolling, getOwnerWindow as $7mdmh$getOwnerWindow } from \"@react-aria/utils\";\nimport { flushSync as $7mdmh$flushSync } from \"react-dom\";\nimport { useContext as $7mdmh$useContext, useState as $7mdmh$useState, useRef as $7mdmh$useRef, useMemo as $7mdmh$useMemo, useEffect as $7mdmh$useEffect } from \"react\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n  // Consume context from <PressResponder> and merge with props.\n  let context = (0, $7mdmh$useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));\n\n  if (context) {\n    let {\n      register: register,\n      ...contextProps\n    } = context;\n    props = (0, $7mdmh$mergeProps)(contextProps, props);\n    register();\n  }\n\n  (0, $7mdmh$useSyncRef)(context, props.ref);\n  return props;\n}\n\nvar $f6c31cce2adf654f$var$_shouldStopPropagation = /*#__PURE__*/new WeakMap();\n\nclass $f6c31cce2adf654f$var$PressEvent {\n  continuePropagation() {\n    (0, $7mdmh$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);\n  }\n\n  get shouldStopPropagation() {\n    return (0, $7mdmh$_)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);\n  }\n\n  constructor(type, pointerType, originalEvent, state) {\n    (0, $7mdmh$_1)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {\n      writable: true,\n      value: void 0\n    });\n    (0, $7mdmh$_2)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);\n\n    var _state_target;\n\n    let currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;\n    const rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();\n    let x,\n        y = 0;\n    let clientX,\n        clientY = null;\n\n    if (originalEvent.clientX != null && originalEvent.clientY != null) {\n      clientX = originalEvent.clientX;\n      clientY = originalEvent.clientY;\n    }\n\n    if (rect) {\n      if (clientX != null && clientY != null) {\n        x = clientX - rect.left;\n        y = clientY - rect.top;\n      } else {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      }\n    }\n\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n    this.x = x;\n    this.y = y;\n  }\n\n}\n\nconst $f6c31cce2adf654f$var$LINK_CLICKED = Symbol('linkClicked');\nconst $f6c31cce2adf654f$var$STYLE_ID = 'react-aria-pressable-style';\nconst $f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE = 'data-react-aria-pressable';\n\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n  let {\n    onPress: onPress,\n    onPressChange: onPressChange,\n    onPressStart: onPressStart,\n    onPressEnd: onPressEnd,\n    onPressUp: onPressUp,\n    onClick: onClick,\n    isDisabled: isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress: preventFocusOnPress,\n    shouldCancelOnPointerExit: shouldCancelOnPointerExit,\n    allowTextSelectionOnPress: allowTextSelectionOnPress,\n    ref: domRef,\n    ...domProps\n  } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n  let [isPressed, setPressed] = (0, $7mdmh$useState)(false);\n  let ref = (0, $7mdmh$useRef)({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null,\n    disposables: []\n  });\n  let {\n    addGlobalListener: addGlobalListener,\n    removeAllGlobalListeners: removeAllGlobalListeners\n  } = (0, $7mdmh$useGlobalListeners)();\n  let triggerPressStart = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) return false;\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n\n    if (onPressStart) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) onPressChange(true);\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  let triggerPressEnd = (0, $7mdmh$useEffectEvent)(function (originalEvent, pointerType) {\n    let wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let state = ref.current;\n    if (!state.didFirePressStart) return false;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    let shouldStopPropagation = true;\n\n    if (onPressEnd) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) onPressChange(false);\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new $f6c31cce2adf654f$var$PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  let triggerPressUp = (0, $7mdmh$useEffectEvent)((originalEvent, pointerType) => {\n    let state = ref.current;\n    if (isDisabled) return false;\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new $f6c31cce2adf654f$var$PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n  let cancel = (0, $7mdmh$useEffectEvent)(e => {\n    let state = ref.current;\n\n    if (state.isPressed && state.target) {\n      if (state.didFirePressStart && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n\n      for (let dispose of state.disposables) dispose();\n\n      state.disposables = [];\n    }\n  });\n  let cancelOnPointerExit = (0, $7mdmh$useEffectEvent)(e => {\n    if (shouldCancelOnPointerExit) cancel(e);\n  });\n  let triggerClick = (0, $7mdmh$useEffectEvent)(e => {\n    onClick === null || onClick === void 0 ? void 0 : onClick(e);\n  });\n  let triggerSyntheticClick = (0, $7mdmh$useEffectEvent)((e, target) => {\n    // Some third-party libraries pass in onClick instead of onPress.\n    // Create a fake mouse event and trigger onClick as well.\n    // This matches the browser's native activation behavior for certain elements (e.g. button).\n    // https://html.spec.whatwg.org/#activation\n    // https://html.spec.whatwg.org/#fire-a-synthetic-pointer-event\n    if (onClick) {\n      let event = new MouseEvent('click', e);\n      (0, $8a9cb279dc87e130$export$c2b7abe5d61ec696)(event, target);\n      onClick((0, $8a9cb279dc87e130$export$525bc4921d56d4a)(event));\n    }\n  });\n  let pressProps = (0, $7mdmh$useMemo)(() => {\n    let state = ref.current;\n    let pressProps = {\n      onKeyDown(e) {\n        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && (0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) {\n          var _state_metaKeyEvents;\n\n          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $7mdmh$getEventTarget)(e.nativeEvent), e.key)) e.preventDefault(); // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n\n          let shouldStopPropagation = true;\n\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            state.pointerType = 'keyboard';\n            shouldStopPropagation = triggerPressStart(e, 'keyboard'); // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n\n            let originalTarget = e.currentTarget;\n\n            let pressUp = e => {\n              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e, originalTarget) && !e.repeat && (0, $7mdmh$nodeContains)(originalTarget, (0, $7mdmh$getEventTarget)(e)) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard');\n            };\n\n            addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'keyup', (0, $7mdmh$chain)(pressUp, onKeyUp), true);\n          }\n\n          if (shouldStopPropagation) e.stopPropagation(); // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n\n          if (e.metaKey && (0, $7mdmh$isMac)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e.key, e.nativeEvent);\n        } else if (e.key === 'Meta') state.metaKeyEvents = new Map();\n      },\n\n      onClick(e) {\n        if (e && !(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(0, $7mdmh$openLink).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) e.preventDefault(); // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n\n          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || (0, $7mdmh$isVirtualClick)(e.nativeEvent))) {\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            triggerClick(e);\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          } else if (state.isPressed && state.pointerType !== 'keyboard') {\n            let pointerType = state.pointerType || e.nativeEvent.pointerType || 'virtual';\n            let stopPressUp = triggerPressUp($f6c31cce2adf654f$var$createEvent(e.currentTarget, e), pointerType);\n            let stopPressEnd = triggerPressEnd($f6c31cce2adf654f$var$createEvent(e.currentTarget, e), pointerType, true);\n            shouldStopPropagation = stopPressUp && stopPressEnd;\n            state.isOverTarget = false;\n            triggerClick(e);\n            cancel(e);\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          if (shouldStopPropagation) e.stopPropagation();\n        }\n      }\n\n    };\n\n    let onKeyUp = e => {\n      var _state_metaKeyEvents;\n\n      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n        var _state_metaKeyEvents1;\n\n        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $7mdmh$getEventTarget)(e), e.key)) e.preventDefault();\n        let target = (0, $7mdmh$getEventTarget)(e);\n        let wasPressed = (0, $7mdmh$nodeContains)(state.target, (0, $7mdmh$getEventTarget)(e));\n        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard', wasPressed);\n        if (wasPressed) triggerSyntheticClick(e, state.target);\n        removeAllGlobalListeners(); // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n\n        if (e.key !== 'Enter' && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && (0, $7mdmh$nodeContains)(state.target, target) && !e[$f6c31cce2adf654f$var$LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[$f6c31cce2adf654f$var$LINK_CLICKED] = true;\n          (0, $7mdmh$openLink)(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n      } else if (e.key === 'Meta' && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n        var _state_target; // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n\n\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n\n        for (let event of events.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent('keyup', event));\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = e => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return; // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n\n        if ((0, $7mdmh$isVirtualPointerEvent)(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        state.pointerType = e.pointerType;\n        let shouldStopPropagation = true;\n\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n          shouldStopPropagation = triggerPressStart(e, state.pointerType); // Release pointer capture so that touch interactions can leave the original target.\n          // This enables onPointerLeave and onPointerEnter to fire.\n\n          let target = (0, $7mdmh$getEventTarget)(e.nativeEvent);\n          if ('releasePointerCapture' in target) target.releasePointerCapture(e.pointerId);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n\n      pressProps.onMouseDown = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n\n        if (e.button === 0) {\n          if (preventFocusOnPress) {\n            let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e.target);\n            if (dispose) state.disposables.push(dispose);\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = e => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent)) || state.pointerType === 'virtual') return; // Only handle left clicks. If isPressed is true, delay until onClick.\n\n        if (e.button === 0 && !state.isPressed) triggerPressUp(e, state.pointerType || e.pointerType);\n      };\n\n      pressProps.onPointerEnter = e => {\n        if (e.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = true;\n          triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n        }\n      };\n\n      pressProps.onPointerLeave = e => {\n        if (e.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = e => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if ((0, $7mdmh$nodeContains)(state.target, (0, $7mdmh$getEventTarget)(e)) && state.pointerType != null) {\n            // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n            // is mutated between onPointerUp and onClick, and is more compatible with third party libraries.\n            // https://github.com/adobe/react-spectrum/issues/1513\n            // https://issues.chromium.org/issues/40732224\n            // However, iOS and Android do not focus or fire onClick after a long press.\n            // We work around this by triggering a click ourselves after a timeout.\n            // This timeout is canceled during the click event in case the real one fires first.\n            // The timeout must be at least 32ms, because Safari on iOS delays the click event on\n            // non-form elements without certain ARIA roles (for hover emulation).\n            // https://github.com/WebKit/WebKit/blob/dccfae42bb29bd4bdef052e469f604a9387241c0/Source/WebKit/WebProcess/WebPage/ios/WebPageIOS.mm#L875-L892\n            let clicked = false;\n            let timeout = setTimeout(() => {\n              if (state.isPressed && state.target instanceof HTMLElement) {\n                if (clicked) cancel(e);else {\n                  (0, $7mdmh$focusWithoutScrolling)(state.target);\n                  state.target.click();\n                }\n              }\n            }, 80); // Use a capturing listener to track if a click occurred.\n            // If stopPropagation is called it may never reach our handler.\n\n            addGlobalListener(e.currentTarget, 'click', () => clicked = true, true);\n            state.disposables.push(() => clearTimeout(timeout));\n          } else cancel(e); // Ignore subsequent onPointerLeave event before onClick on touch devices.\n\n\n          state.isOverTarget = false;\n        }\n      };\n\n      let onPointerCancel = e => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return; // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n\n        cancel(e);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      // NOTE: this fallback branch is entirely used by unit tests.\n      // All browsers now support pointer events, but JSDOM still does not.\n      pressProps.onMouseDown = e => {\n        // Only handle left clicks\n        if (e.button !== 0 || !(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = (0, $7mdmh$isVirtualClick)(e.nativeEvent) ? 'virtual' : 'mouse'; // Flush sync so that focus moved during react re-renders occurs before we yield back to the browser.\n\n        let shouldStopPropagation = (0, $7mdmh$flushSync)(() => triggerPressStart(e, state.pointerType));\n        if (shouldStopPropagation) e.stopPropagation();\n\n        if (preventFocusOnPress) {\n          let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e.target);\n          if (dispose) state.disposables.push(dispose);\n        }\n\n        addGlobalListener((0, $7mdmh$getOwnerDocument)(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        let shouldStopPropagation = true;\n\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n\n      pressProps.onMouseLeave = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        let shouldStopPropagation = true;\n\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n\n      pressProps.onMouseUp = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0 && !state.isPressed) triggerPressUp(e, state.pointerType || 'mouse');\n      };\n\n      let onMouseUp = e => {\n        // Only handle left clicks\n        if (e.button !== 0) return;\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && state.target.contains(e.target) && state.pointerType != null) ;else cancel(e);\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n        if (!touch) return;\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n        if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);\n        let shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener((0, $7mdmh$getOwnerWindow)(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n\n        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit($f6c31cce2adf654f$var$createTouchEvent(state.target, e));\n        }\n\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n\n      pressProps.onTouchEnd = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n\n        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType);\n          triggerSyntheticClick(e.nativeEvent, state.target);\n        } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e), state.pointerType, false);\n\n        if (shouldStopPropagation) e.stopPropagation();\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        e.stopPropagation();\n        if (state.isPressed) cancel($f6c31cce2adf654f$var$createTouchEvent(state.target, e));\n      };\n\n      let onScroll = e => {\n        if (state.isPressed && (0, $7mdmh$nodeContains)((0, $7mdmh$getEventTarget)(e), state.target)) cancel({\n          currentTarget: state.target,\n          shiftKey: false,\n          ctrlKey: false,\n          metaKey: false,\n          altKey: false\n        });\n      };\n\n      pressProps.onDragStart = e => {\n        if (!(0, $7mdmh$nodeContains)(e.currentTarget, (0, $7mdmh$getEventTarget)(e.nativeEvent))) return;\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp, triggerClick, triggerSyntheticClick]); // Avoid onClick delay for double tap to zoom by default.\n\n  (0, $7mdmh$useEffect)(() => {\n    if (!domRef || process.env.NODE_ENV === 'test') return;\n    const ownerDocument = (0, $7mdmh$getOwnerDocument)(domRef.current);\n    if (!ownerDocument || !ownerDocument.head || ownerDocument.getElementById($f6c31cce2adf654f$var$STYLE_ID)) return;\n    const style = ownerDocument.createElement('style');\n    style.id = $f6c31cce2adf654f$var$STYLE_ID; // touchAction: 'manipulation' is supposed to be equivalent, but in\n    // Safari it causes onPointerCancel not to fire on scroll.\n    // https://bugs.webkit.org/show_bug.cgi?id=240917\n\n    style.textContent = `\n@layer {\n  [${$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE}] {\n    touch-action: pan-x pan-y pinch-zoom;\n  }\n}\n    `.trim();\n    ownerDocument.head.prepend(style);\n  }, [domRef]); // Remove user-select: none in case component unmounts immediately after pressStart\n\n  (0, $7mdmh$useEffect)(() => {\n    let state = ref.current;\n    return () => {\n      var _state_target;\n\n      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_state_target = state.target) !== null && _state_target !== void 0 ? _state_target : undefined);\n\n      for (let dispose of state.disposables) dispose();\n\n      state.disposables = [];\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: (0, $7mdmh$mergeProps)(domProps, pressProps, {\n      [$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE]: true\n    })\n  };\n}\n\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n  const {\n    key: key,\n    code: code\n  } = event;\n  const element = currentTarget;\n  const role = element.getAttribute('role'); // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n\n  return (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') && !(element instanceof (0, $7mdmh$getOwnerWindow)(element).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof (0, $7mdmh$getOwnerWindow)(element).HTMLTextAreaElement || element.isContentEditable) && // Links should only trigger with Enter key\n  !((role === 'link' || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element)) && key !== 'Enter');\n}\n\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n  const {\n    targetTouches: targetTouches\n  } = event;\n  if (targetTouches.length > 0) return targetTouches[0];\n  return null;\n}\n\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n  const changedTouches = event.changedTouches;\n\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) return touch;\n  }\n\n  return null;\n}\n\nfunction $f6c31cce2adf654f$var$createTouchEvent(target, e) {\n  let clientX = 0;\n  let clientY = 0;\n\n  if (e.targetTouches && e.targetTouches.length === 1) {\n    clientX = e.targetTouches[0].clientX;\n    clientY = e.targetTouches[0].clientY;\n  }\n\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX: clientX,\n    clientY: clientY\n  };\n}\n\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n  let clientX = e.clientX;\n  let clientY = e.clientY;\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX: clientX,\n    clientY: clientY\n  };\n}\n\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) offsetX = point.width / 2;else if (point.radiusX !== undefined) offsetX = point.radiusX;\n  if (point.height !== undefined) offsetY = point.height / 2;else if (point.radiusY !== undefined) offsetY = point.radiusY;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) return false; // check if they cannot overlap on y axis\n\n  if (a.top > b.bottom || b.top > a.bottom) return false;\n  return true;\n}\n\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n  return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultUp(target) {\n  if (target instanceof HTMLInputElement) return false;\n  if (target instanceof HTMLButtonElement) return target.type !== 'submit' && target.type !== 'reset';\n  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;\n  return true;\n}\n\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n  return $f6c31cce2adf654f$var$shouldPreventDefaultUp(target);\n}\n\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\n\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio' ? key === ' ' : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\n\nexport { $f6c31cce2adf654f$export$45712eceda6fad21 as usePress };","map":{"version":3,"mappings":"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","names":["$f6c31cce2adf654f$var$usePressResponderContext","props","context","register","contextProps","ref","$f6c31cce2adf654f$var$_shouldStopPropagation","$f6c31cce2adf654f$var$PressEvent","continuePropagation","constructor","type","pointerType","originalEvent","state","_state_target","currentTarget","target","rect","getBoundingClientRect","x","y","clientX","clientY","left","top","width","height","shiftKey","metaKey","ctrlKey","altKey","$f6c31cce2adf654f$var$LINK_CLICKED","Symbol","$f6c31cce2adf654f$var$STYLE_ID","$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE","$f6c31cce2adf654f$export$45712eceda6fad21","onPress","onPressChange","onPressStart","onPressEnd","onPressUp","onClick","isDisabled","isPressed","isPressedProp","preventFocusOnPress","shouldCancelOnPointerExit","allowTextSelectionOnPress","domRef","domProps","setPressed","ignoreEmulatedMouseEvents","didFirePressStart","isTriggeringEvent","activePointerId","isOverTarget","disposables","addGlobalListener","removeAllGlobalListeners","triggerPressStart","current","shouldStopPropagation","event","triggerPressEnd","wasPressed","triggerPressUp","cancel","e","$f6c31cce2adf654f$var$createEvent","dispose","cancelOnPointerExit","triggerClick","triggerSyntheticClick","MouseEvent","pressProps","onKeyDown","$f6c31cce2adf654f$var$isValidKeyboardEvent","nativeEvent","_state_metaKeyEvents","$f6c31cce2adf654f$var$shouldPreventDefaultKeyboard","key","preventDefault","repeat","originalTarget","pressUp","onKeyUp","stopPropagation","metaKeyEvents","set","Map","button","isOpening","stopPressStart","stopPressUp","stopPressEnd","_state_metaKeyEvents1","$f6c31cce2adf654f$var$isHTMLAnchorLink","delete","size","events","undefined","values","dispatchEvent","KeyboardEvent","PointerEvent","onPointerDown","pointerId","releasePointerCapture","onPointerUp","onPointerCancel","onMouseDown","push","onPointerEnter","onPointerLeave","clicked","timeout","setTimeout","HTMLElement","click","clearTimeout","onDragStart","process","env","NODE_ENV","onMouseUp","onMouseEnter","onMouseLeave","contains","onTouchStart","touch","$f6c31cce2adf654f$var$getTouchFromEvent","identifier","$f6c31cce2adf654f$var$createTouchEvent","onScroll","onTouchMove","$f6c31cce2adf654f$var$getTouchById","$f6c31cce2adf654f$var$isOverTarget","onTouchEnd","onTouchCancel","ownerDocument","head","getElementById","style","createElement","id","textContent","trim","prepend","tagName","hasAttribute","code","element","role","getAttribute","HTMLInputElement","$f6c31cce2adf654f$var$isValidInputKey","HTMLTextAreaElement","isContentEditable","targetTouches","length","changedTouches","i","$f6c31cce2adf654f$var$getPointClientRect","point","offsetX","offsetY","radiusX","radiusY","right","bottom","$f6c31cce2adf654f$var$areRectanglesOverlapping","a","b","pointRect","$f6c31cce2adf654f$var$shouldPreventDefaultUp","HTMLButtonElement","$f6c31cce2adf654f$var$nonTextInputTypes","Set","has"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\usePress.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {\n  chain,\n  focusWithoutScrolling,\n  getEventTarget,\n  getOwnerDocument,\n  getOwnerWindow,\n  isMac,\n  isVirtualClick,\n  isVirtualPointerEvent,\n  mergeProps,\n  nodeContains,\n  openLink,\n  useEffectEvent,\n  useGlobalListeners,\n  useSyncRef\n} from '@react-aria/utils';\nimport {createSyntheticEvent, preventFocus, setEventTarget} from './utils';\nimport {disableTextSelection, restoreTextSelection} from './textSelection';\nimport {DOMAttributes, FocusableElement, PressEvent as IPressEvent, PointerType, PressEvents, RefObject} from '@react-types/shared';\nimport {flushSync} from 'react-dom';\nimport {PressResponderContext} from './context';\nimport {MouseEvent as RMouseEvent, TouchEvent as RTouchEvent, useContext, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface PressProps extends PressEvents {\n  /** Whether the target is in a controlled press state (e.g. an overlay it triggers is open). */\n  isPressed?: boolean,\n  /** Whether the press events should be disabled. */\n  isDisabled?: boolean,\n  /** Whether the target should not receive focus on press. */\n  preventFocusOnPress?: boolean,\n  /**\n   * Whether press events should be canceled when the pointer leaves the target while pressed.\n   * By default, this is `false`, which means if the pointer returns back over the target while\n   * still pressed, onPressStart will be fired again. If set to `true`, the press is canceled\n   * when the pointer leaves the target and onPressStart will not be fired if the pointer returns.\n   */\n  shouldCancelOnPointerExit?: boolean,\n  /** Whether text selection should be enabled on the pressable element. */\n  allowTextSelectionOnPress?: boolean\n}\n\nexport interface PressHookProps extends PressProps {\n  /** A ref to the target element. */\n  ref?: RefObject<Element | null>\n}\n\ninterface PressState {\n  isPressed: boolean,\n  ignoreEmulatedMouseEvents: boolean,\n  didFirePressStart: boolean,\n  isTriggeringEvent: boolean,\n  activePointerId: any,\n  target: FocusableElement | null,\n  isOverTarget: boolean,\n  pointerType: PointerType | null,\n  userSelect?: string,\n  metaKeyEvents?: Map<string, KeyboardEvent>,\n  disposables: Array<() => void>\n}\n\ninterface EventBase {\n  currentTarget: EventTarget | null,\n  shiftKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean,\n  altKey: boolean,\n  clientX?: number,\n  clientY?: number,\n  targetTouches?: Array<{clientX?: number, clientY?: number}>\n}\n\nexport interface PressResult {\n  /** Whether the target is currently pressed. */\n  isPressed: boolean,\n  /** Props to spread on the target element. */\n  pressProps: DOMAttributes\n}\n\nfunction usePressResponderContext(props: PressHookProps): PressHookProps {\n  // Consume context from <PressResponder> and merge with props.\n  let context = useContext(PressResponderContext);\n  if (context) {\n    let {register, ...contextProps} = context;\n    props = mergeProps(contextProps, props) as PressHookProps;\n    register();\n  }\n  useSyncRef(context, props.ref);\n\n  return props;\n}\n\nclass PressEvent implements IPressEvent {\n  type: IPressEvent['type'];\n  pointerType: PointerType;\n  target: Element;\n  shiftKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  altKey: boolean;\n  x: number;\n  y: number;\n  #shouldStopPropagation = true;\n\n  constructor(type: IPressEvent['type'], pointerType: PointerType, originalEvent: EventBase, state?: PressState) {\n    let currentTarget = state?.target ?? originalEvent.currentTarget;\n    const rect: DOMRect | undefined = (currentTarget as Element)?.getBoundingClientRect();\n    let x, y = 0;\n    let clientX, clientY: number | null = null;\n    if (originalEvent.clientX != null && originalEvent.clientY != null) {\n      clientX = originalEvent.clientX;\n      clientY = originalEvent.clientY;\n    }\n    if (rect) {\n      if (clientX != null && clientY != null) {\n        x = clientX - rect.left;\n        y = clientY - rect.top;\n      } else {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      }\n    }\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget as Element;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n    this.x = x;\n    this.y = y;\n  }\n\n  continuePropagation() {\n    this.#shouldStopPropagation = false;\n  }\n\n  get shouldStopPropagation() {\n    return this.#shouldStopPropagation;\n  }\n}\n\nconst LINK_CLICKED = Symbol('linkClicked');\nconst STYLE_ID = 'react-aria-pressable-style';\nconst PRESSABLE_ATTRIBUTE = 'data-react-aria-pressable';\n\n/**\n * Handles press interactions across mouse, touch, keyboard, and screen readers.\n * It normalizes behavior across browsers and platforms, and handles many nuances\n * of dealing with pointer and keyboard events.\n */\nexport function usePress(props: PressHookProps): PressResult {\n  let {\n    onPress,\n    onPressChange,\n    onPressStart,\n    onPressEnd,\n    onPressUp,\n    onClick,\n    isDisabled,\n    isPressed: isPressedProp,\n    preventFocusOnPress,\n    shouldCancelOnPointerExit,\n    allowTextSelectionOnPress,\n    ref: domRef,\n    ...domProps\n  } = usePressResponderContext(props);\n\n  let [isPressed, setPressed] = useState(false);\n  let ref = useRef<PressState>({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null,\n    disposables: []\n  });\n\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let triggerPressStart = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled || state.didFirePressStart) {\n      return false;\n    }\n\n    let shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      let event = new PressEvent('pressstart', pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(true);\n    }\n\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n\n  let triggerPressEnd = useEffectEvent((originalEvent: EventBase, pointerType: PointerType, wasPressed = true) => {\n    let state = ref.current;\n    if (!state.didFirePressStart) {\n      return false;\n    }\n\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n\n    let shouldStopPropagation = true;\n    if (onPressEnd) {\n      let event = new PressEvent('pressend', pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n\n    if (onPressChange) {\n      onPressChange(false);\n    }\n\n    setPressed(false);\n\n    if (onPress && wasPressed && !isDisabled) {\n      let event = new PressEvent('press', pointerType, originalEvent);\n      onPress(event);\n      shouldStopPropagation &&= event.shouldStopPropagation;\n    }\n\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n\n  let triggerPressUp = useEffectEvent((originalEvent: EventBase, pointerType: PointerType) => {\n    let state = ref.current;\n    if (isDisabled) {\n      return false;\n    }\n\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      let event = new PressEvent('pressup', pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n\n    return true;\n  });\n\n  let cancel = useEffectEvent((e: EventBase) => {\n    let state = ref.current;\n    if (state.isPressed && state.target) {\n      if (state.didFirePressStart && state.pointerType != null) {\n        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n      }\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target);\n      }\n      for (let dispose of state.disposables) {\n        dispose();\n      }\n      state.disposables = [];\n    }\n  });\n\n  let cancelOnPointerExit = useEffectEvent((e: EventBase) => {\n    if (shouldCancelOnPointerExit) {\n      cancel(e);\n    }\n  });\n\n  let triggerClick = useEffectEvent((e: RMouseEvent<FocusableElement>) => {\n    onClick?.(e);\n  });\n\n  let triggerSyntheticClick = useEffectEvent((e: KeyboardEvent | TouchEvent, target: FocusableElement) => {\n    // Some third-party libraries pass in onClick instead of onPress.\n    // Create a fake mouse event and trigger onClick as well.\n    // This matches the browser's native activation behavior for certain elements (e.g. button).\n    // https://html.spec.whatwg.org/#activation\n    // https://html.spec.whatwg.org/#fire-a-synthetic-pointer-event\n    if (onClick) {\n      let event = new MouseEvent('click', e);\n      setEventTarget(event, target);\n      onClick(createSyntheticEvent(event));\n    }\n  });\n\n  let pressProps = useMemo(() => {\n    let state = ref.current;\n    let pressProps: DOMAttributes = {\n      onKeyDown(e) {\n        if (isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          if (shouldPreventDefaultKeyboard(getEventTarget(e.nativeEvent), e.key)) {\n            e.preventDefault();\n          }\n\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          let shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            state.pointerType = 'keyboard';\n            shouldStopPropagation = triggerPressStart(e, 'keyboard');\n\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred. Make it capturing so that it will trigger\n            // before stopPropagation from useKeyboard on a child element may happen and thus we can still call triggerPress for the parent element.\n            let originalTarget = e.currentTarget;\n            let pressUp = (e) => {\n              if (isValidKeyboardEvent(e, originalTarget) && !e.repeat && nodeContains(originalTarget, getEventTarget(e)) && state.target) {\n                triggerPressUp(createEvent(state.target, e), 'keyboard');\n              }\n            };\n\n            addGlobalListener(getOwnerDocument(e.currentTarget), 'keyup', chain(pressUp, onKeyUp), true);\n          }\n\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && isMac()) {\n            state.metaKeyEvents?.set(e.key, e.nativeEvent);\n          }\n        } else if (e.key === 'Meta') {\n          state.metaKeyEvents = new Map();\n        }\n      },\n      onClick(e) {\n        if (e && !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(openLink as any).isOpening) {\n          let shouldStopPropagation = true;\n          if (isDisabled) {\n            e.preventDefault();\n          }\n          \n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === 'virtual' || isVirtualClick(e.nativeEvent))) {\n            let stopPressStart = triggerPressStart(e, 'virtual');\n            let stopPressUp = triggerPressUp(e, 'virtual');\n            let stopPressEnd = triggerPressEnd(e, 'virtual');\n            triggerClick(e);\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          } else if (state.isPressed && state.pointerType !== 'keyboard') {\n            let pointerType = state.pointerType || (e.nativeEvent as PointerEvent).pointerType as PointerType || 'virtual';\n            let stopPressUp = triggerPressUp(createEvent(e.currentTarget, e), pointerType);\n            let stopPressEnd =  triggerPressEnd(createEvent(e.currentTarget, e), pointerType, true);\n            shouldStopPropagation = stopPressUp && stopPressEnd;\n            state.isOverTarget = false;\n            triggerClick(e);\n            cancel(e);\n          }\n\n          state.ignoreEmulatedMouseEvents = false;\n          if (shouldStopPropagation) {\n            e.stopPropagation();\n          }\n        }\n      }\n    };\n\n    let onKeyUp = (e: KeyboardEvent) => {\n      if (state.isPressed && state.target && isValidKeyboardEvent(e, state.target)) {\n        if (shouldPreventDefaultKeyboard(getEventTarget(e), e.key)) {\n          e.preventDefault();\n        }\n\n        let target = getEventTarget(e);\n        let wasPressed = nodeContains(state.target, getEventTarget(e));\n        triggerPressEnd(createEvent(state.target, e), 'keyboard', wasPressed);\n        if (wasPressed) {\n          triggerSyntheticClick(e, state.target);\n        }\n        removeAllGlobalListeners();\n\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== 'Enter' && isHTMLAnchorLink(state.target) && nodeContains(state.target, target) && !e[LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[LINK_CLICKED] = true;\n          openLink(state.target, e, false);\n        }\n\n        state.isPressed = false;\n        state.metaKeyEvents?.delete(e.key);\n      } else if (e.key === 'Meta' && state.metaKeyEvents?.size) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        let events = state.metaKeyEvents;\n        state.metaKeyEvents = undefined;\n        for (let event of events.values()) {\n          state.target?.dispatchEvent(new KeyboardEvent('keyup', event));\n        }\n      }\n    };\n\n    if (typeof PointerEvent !== 'undefined') {\n      pressProps.onPointerDown = (e) => {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if (isVirtualPointerEvent(e.nativeEvent)) {\n          state.pointerType = 'virtual';\n          return;\n        }\n\n        state.pointerType = e.pointerType;\n\n        let shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget as FocusableElement;\n\n          if (!allowTextSelectionOnPress) {\n            disableTextSelection(state.target);\n          }\n\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n\n          // Release pointer capture so that touch interactions can leave the original target.\n          // This enables onPointerLeave and onPointerEnter to fire.\n          let target = getEventTarget(e.nativeEvent);\n          if ('releasePointerCapture' in target) {\n            target.releasePointerCapture(e.pointerId);\n          }\n\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointerup', onPointerUp, false);\n          addGlobalListener(getOwnerDocument(e.currentTarget), 'pointercancel', onPointerCancel, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseDown = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (e.button === 0) {\n          if (preventFocusOnPress) {\n            let dispose = preventFocus(e.target as FocusableElement);\n            if (dispose) {\n              state.disposables.push(dispose);\n            }\n          }\n\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onPointerUp = (e) => {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent)) || state.pointerType === 'virtual') {\n          return;\n        }\n\n        // Only handle left clicks. If isPressed is true, delay until onClick.\n        if (e.button === 0 && !state.isPressed) {\n          triggerPressUp(e, state.pointerType || e.pointerType);\n        }\n      };\n\n      pressProps.onPointerEnter = (e) => {\n        if (e.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = true;\n          triggerPressStart(createEvent(state.target, e), state.pointerType);\n        }\n      };\n\n      pressProps.onPointerLeave = (e) => {\n        if (e.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          triggerPressEnd(createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n\n      let onPointerUp = (e: PointerEvent) => {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0 && state.target) {\n          if (nodeContains(state.target, getEventTarget(e)) && state.pointerType != null) {\n            // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n            // is mutated between onPointerUp and onClick, and is more compatible with third party libraries.\n            // https://github.com/adobe/react-spectrum/issues/1513\n            // https://issues.chromium.org/issues/40732224\n            // However, iOS and Android do not focus or fire onClick after a long press.\n            // We work around this by triggering a click ourselves after a timeout.\n            // This timeout is canceled during the click event in case the real one fires first.\n            // The timeout must be at least 32ms, because Safari on iOS delays the click event on\n            // non-form elements without certain ARIA roles (for hover emulation).\n            // https://github.com/WebKit/WebKit/blob/dccfae42bb29bd4bdef052e469f604a9387241c0/Source/WebKit/WebProcess/WebPage/ios/WebPageIOS.mm#L875-L892\n            let clicked = false;\n            let timeout = setTimeout(() => {\n              if (state.isPressed && state.target instanceof HTMLElement) {\n                if (clicked) {\n                  cancel(e);\n                } else {\n                  focusWithoutScrolling(state.target);\n                  state.target.click();\n                }\n              }\n            }, 80);\n            // Use a capturing listener to track if a click occurred.\n            // If stopPropagation is called it may never reach our handler.\n            addGlobalListener(e.currentTarget as Document, 'click', () => clicked = true, true);\n            state.disposables.push(() => clearTimeout(timeout));\n          } else {\n            cancel(e);\n          }\n\n          // Ignore subsequent onPointerLeave event before onClick on touch devices.\n          state.isOverTarget = false;\n        }\n      };\n\n      let onPointerCancel = (e: PointerEvent) => {\n        cancel(e);\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      // NOTE: this fallback branch is entirely used by unit tests.\n      // All browsers now support pointer events, but JSDOM still does not.\n\n      pressProps.onMouseDown = (e) => {\n        // Only handle left clicks\n        if (e.button !== 0 || !nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n\n        // Flush sync so that focus moved during react re-renders occurs before we yield back to the browser.\n        let shouldStopPropagation = flushSync(() => triggerPressStart(e, state.pointerType!));\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        if (preventFocusOnPress) {\n          let dispose = preventFocus(e.target as FocusableElement);\n          if (dispose) {\n            state.disposables.push(dispose);\n          }\n        }\n\n        addGlobalListener(getOwnerDocument(e.currentTarget), 'mouseup', onMouseUp, false);\n      };\n\n      pressProps.onMouseEnter = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseLeave = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onMouseUp = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0 && !state.isPressed) {\n          triggerPressUp(e, state.pointerType || 'mouse');\n        }\n      };\n\n      let onMouseUp = (e: MouseEvent) => {\n        // Only handle left clicks\n        if (e.button !== 0) {\n          return;\n        }\n\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n\n        if (state.target && state.target.contains(e.target as Element) && state.pointerType != null) {\n          // Wait for onClick to fire onPress. This avoids browser issues when the DOM\n          // is mutated between onMouseUp and onClick, and is more compatible with third party libraries.\n        } else {\n          cancel(e);\n        }\n\n        state.isOverTarget = false;\n      };\n\n      pressProps.onTouchStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        let touch = getTouchFromEvent(e.nativeEvent);\n        if (!touch) {\n          return;\n        }\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = 'touch';\n\n        if (!allowTextSelectionOnPress) {\n          disableTextSelection(state.target);\n        }\n\n        let shouldStopPropagation = triggerPressStart(createTouchEvent(state.target, e), state.pointerType);\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        addGlobalListener(getOwnerWindow(e.currentTarget), 'scroll', onScroll, true);\n      };\n\n      pressProps.onTouchMove = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget && state.pointerType != null) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(createTouchEvent(state.target!, e), state.pointerType);\n          }\n        } else if (state.isOverTarget && state.pointerType != null) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType, false);\n          cancelOnPointerExit(createTouchEvent(state.target!, e));\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n      };\n\n      pressProps.onTouchEnd = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n\n        let touch = getTouchById(e.nativeEvent, state.activePointerId);\n        let shouldStopPropagation = true;\n        if (touch && isOverTarget(touch, e.currentTarget) && state.pointerType != null) {\n          triggerPressUp(createTouchEvent(state.target!, e), state.pointerType);\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType);\n          triggerSyntheticClick(e.nativeEvent, state.target!);\n        } else if (state.isOverTarget && state.pointerType != null) {\n          shouldStopPropagation = triggerPressEnd(createTouchEvent(state.target!, e), state.pointerType, false);\n        }\n\n        if (shouldStopPropagation) {\n          e.stopPropagation();\n        }\n\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.target && !allowTextSelectionOnPress) {\n          restoreTextSelection(state.target);\n        }\n        removeAllGlobalListeners();\n      };\n\n      pressProps.onTouchCancel = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        e.stopPropagation();\n        if (state.isPressed) {\n          cancel(createTouchEvent(state.target!, e));\n        }\n      };\n\n      let onScroll = (e: Event) => {\n        if (state.isPressed && nodeContains(getEventTarget(e), state.target)) {\n          cancel({\n            currentTarget: state.target,\n            shiftKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            altKey: false\n          });\n        }\n      };\n\n      pressProps.onDragStart = (e) => {\n        if (!nodeContains(e.currentTarget, getEventTarget(e.nativeEvent))) {\n          return;\n        }\n\n        cancel(e);\n      };\n    }\n\n    return pressProps;\n  }, [\n    addGlobalListener,\n    isDisabled,\n    preventFocusOnPress,\n    removeAllGlobalListeners,\n    allowTextSelectionOnPress,\n    cancel,\n    cancelOnPointerExit,\n    triggerPressEnd,\n    triggerPressStart,\n    triggerPressUp,\n    triggerClick,\n    triggerSyntheticClick\n  ]);\n\n  // Avoid onClick delay for double tap to zoom by default.\n  useEffect(() => {\n    if (!domRef || process.env.NODE_ENV === 'test') {\n      return;\n    }\n\n    const ownerDocument = getOwnerDocument(domRef.current);\n    if (!ownerDocument || !ownerDocument.head || ownerDocument.getElementById(STYLE_ID)) {\n      return;\n    }\n\n    const style = ownerDocument.createElement('style');\n    style.id = STYLE_ID;\n    // touchAction: 'manipulation' is supposed to be equivalent, but in\n    // Safari it causes onPointerCancel not to fire on scroll.\n    // https://bugs.webkit.org/show_bug.cgi?id=240917\n    style.textContent = `\n@layer {\n  [${PRESSABLE_ATTRIBUTE}] {\n    touch-action: pan-x pan-y pinch-zoom;\n  }\n}\n    `.trim();\n    ownerDocument.head.prepend(style);\n  }, [domRef]);\n\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  useEffect(() => {\n    let state = ref.current;\n    return () => {\n      if (!allowTextSelectionOnPress) {\n        restoreTextSelection(state.target ?? undefined);\n      }\n      for (let dispose of state.disposables) {\n        dispose();\n      }\n      state.disposables = [];\n    };\n  }, [allowTextSelectionOnPress]);\n\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: mergeProps(domProps, pressProps, {[PRESSABLE_ATTRIBUTE]: true})\n  };\n}\n\nfunction isHTMLAnchorLink(target: Element): target is HTMLAnchorElement {\n  return target.tagName === 'A' && target.hasAttribute('href');\n}\n\nfunction isValidKeyboardEvent(event: KeyboardEvent, currentTarget: Element): boolean {\n  const {key, code} = event;\n  const element = currentTarget as HTMLElement;\n  const role = element.getAttribute('role');\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (\n    (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') &&\n    !((element instanceof getOwnerWindow(element).HTMLInputElement && !isValidInputKey(element, key)) ||\n      element instanceof getOwnerWindow(element).HTMLTextAreaElement ||\n      element.isContentEditable) &&\n    // Links should only trigger with Enter key\n    !((role === 'link' || (!role && isHTMLAnchorLink(element))) && key !== 'Enter')\n  );\n}\n\nfunction getTouchFromEvent(event: TouchEvent): Touch | null {\n  const {targetTouches} = event;\n  if (targetTouches.length > 0) {\n    return targetTouches[0];\n  }\n  return null;\n}\n\nfunction getTouchById(\n  event: TouchEvent,\n  pointerId: null | number\n): null | Touch {\n  const changedTouches = event.changedTouches;\n  for (let i = 0; i < changedTouches.length; i++) {\n    const touch = changedTouches[i];\n    if (touch.identifier === pointerId) {\n      return touch;\n    }\n  }\n  return null;\n}\n\nfunction createTouchEvent(target: FocusableElement, e: RTouchEvent<FocusableElement>): EventBase {\n  let clientX = 0;\n  let clientY = 0;\n  if (e.targetTouches && e.targetTouches.length === 1) {\n    clientX = e.targetTouches[0].clientX;\n    clientY = e.targetTouches[0].clientY;\n  }\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX,\n    clientY\n  };\n}\n\nfunction createEvent(target: FocusableElement, e: EventBase): EventBase {\n  let clientX = e.clientX;\n  let clientY = e.clientY;\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    clientX,\n    clientY\n  };\n}\n\ninterface Rect {\n  top: number,\n  right: number,\n  bottom: number,\n  left: number\n}\n\ninterface EventPoint {\n  clientX: number,\n  clientY: number,\n  width?: number,\n  height?: number,\n  radiusX?: number,\n  radiusY?: number\n}\n\nfunction getPointClientRect(point: EventPoint): Rect {\n  let offsetX = 0;\n  let offsetY = 0;\n  if (point.width !== undefined) {\n    offsetX = (point.width / 2);\n  } else if (point.radiusX !== undefined) {\n    offsetX = point.radiusX;\n  }\n  if (point.height !== undefined) {\n    offsetY = (point.height / 2);\n  } else if (point.radiusY !== undefined) {\n    offsetY = point.radiusY;\n  }\n\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\n\nfunction areRectanglesOverlapping(a: Rect, b: Rect) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) {\n    return false;\n  }\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) {\n    return false;\n  }\n  return true;\n}\n\nfunction isOverTarget(point: EventPoint, target: Element) {\n  let rect = target.getBoundingClientRect();\n  let pointRect = getPointClientRect(point);\n  return areRectanglesOverlapping(rect, pointRect);\n}\n\nfunction shouldPreventDefaultUp(target: Element) {\n  if (target instanceof HTMLInputElement) {\n    return false;\n  }\n\n  if (target instanceof HTMLButtonElement) {\n    return target.type !== 'submit' && target.type !== 'reset';\n  }\n\n  if (isHTMLAnchorLink(target)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction shouldPreventDefaultKeyboard(target: Element, key: string) {\n  if (target instanceof HTMLInputElement) {\n    return !isValidInputKey(target, key);\n  }\n\n  return shouldPreventDefaultUp(target);\n}\n\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\nfunction isValidInputKey(target: HTMLInputElement, key: string) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === 'checkbox' || target.type === 'radio'\n    ? key === ' '\n    : nonTextInputTypes.has(target.type);\n}\n"]},"metadata":{},"sourceType":"module"}
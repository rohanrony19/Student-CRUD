{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map(); // A list of callbacks to call once there are no transitioning elements.\n\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\n\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n  if (typeof window === 'undefined') return;\n\n  function isTransitionEvent(event) {\n    return 'propertyName' in event;\n  }\n\n  let onTransitionStart = e => {\n    if (!isTransitionEvent(e) || !e.target) return; // Add the transitioning property to the list for this element.\n\n    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n\n    if (!transitions) {\n      transitions = new Set();\n      $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions); // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n\n      e.target.addEventListener('transitioncancel', onTransitionEnd, {\n        once: true\n      });\n    }\n\n    transitions.add(e.propertyName);\n  };\n\n  let onTransitionEnd = e => {\n    if (!isTransitionEvent(e) || !e.target) return; // Remove property from list of transitioning properties.\n\n    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n    if (!properties) return;\n    properties.delete(e.propertyName); // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n\n    if (properties.size === 0) {\n      e.target.removeEventListener('transitioncancel', onTransitionEnd);\n      $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n    } // If no transitioning elements, call all of the queued callbacks.\n\n\n    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks) cb();\n\n      $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n    }\n  };\n\n  document.body.addEventListener('transitionrun', onTransitionStart);\n  document.body.addEventListener('transitionend', onTransitionEnd);\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') $bbed8b41f857bcc0$var$setupGlobalEvents();else document.addEventListener('DOMContentLoaded', $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\n/**\n * Cleans up any elements that are no longer in the document.\n * This is necessary because we can't rely on transitionend events to fire\n * for elements that are removed from the document while transitioning.\n */\n\n\nfunction $bbed8b41f857bcc0$var$cleanupDetachedElements() {\n  for (const [eventTarget] of $bbed8b41f857bcc0$var$transitionsByElement) // Similar to `eventTarget instanceof Element && !eventTarget.isConnected`, but avoids\n  // the explicit instanceof check, since it may be different in different contexts.\n  if ('isConnected' in eventTarget && !eventTarget.isConnected) $bbed8b41f857bcc0$var$transitionsByElement.delete(eventTarget);\n}\n\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    $bbed8b41f857bcc0$var$cleanupDetachedElements(); // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n\n    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n  });\n}\n\nexport { $bbed8b41f857bcc0$export$24490316f764c430 as runAfterTransition };","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,6CAAuB,IAAIC,GAAJ,EAA3B,C,CAEA;;AACA,IAAIC,4CAAsB,IAAIC,GAAJ,EAA1B;;AAEA,SAASC,uCAAT,GAAS;EACP,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EACE;;EAGF,SAASC,iBAAT,CAA2BC,KAA3B,EAAuC;IACrC,OAAO,kBAAkBA,KAAzB;EACF;;EAEA,IAAIC,oBAAqBC,CAAD,IAAC;IACvB,IAAI,CAACH,kBAAkBG,CAAlB,CAAD,IAAyB,CAACA,EAAEC,MAAhC,EACE,OAFqB,CAIvB;;IACA,IAAIC,cAAcX,2CAAqBY,GAArB,CAAyBH,EAAEC,MAA3B,CAAlB;;IACA,IAAI,CAACC,WAAL,EAAkB;MAChBA,cAAc,IAAIR,GAAJ,EAAd;MACAH,2CAAqBa,GAArB,CAAyBJ,EAAEC,MAA3B,EAAmCC,WAAnC,EAFgB,CAIhB;MACA;MACA;;MACAF,EAAEC,MAAF,CAASI,gBAAT,CAA0B,kBAA1B,EAA8CC,eAA9C,EAA+D;QAC7DC,MAAM;MADuD,CAA/D;IAGF;;IAEAL,YAAYM,GAAZ,CAAgBR,EAAES,YAAlB;EACF,CAnBA;;EAqBA,IAAIH,kBAAmBN,CAAD,IAAC;IACrB,IAAI,CAACH,kBAAkBG,CAAlB,CAAD,IAAyB,CAACA,EAAEC,MAAhC,EACE,OAFmB,CAIrB;;IACA,IAAIS,aAAanB,2CAAqBY,GAArB,CAAyBH,EAAEC,MAA3B,CAAjB;IACA,IAAI,CAACS,UAAL,EACE;IAGFA,WAAWC,MAAX,CAAkBX,EAAES,YAApB,EAVqB,CAYrB;;IACA,IAAIC,WAAWE,IAAX,KAAoB,CAAxB,EAA2B;MACzBZ,EAAEC,MAAF,CAASY,mBAAT,CAA6B,kBAA7B,EAAiDP,eAAjD;MACAf,2CAAqBoB,MAArB,CAA4BX,EAAEC,MAA9B;IACF,CAhBqB,CAkBrB;;;IACA,IAAIV,2CAAqBqB,IAArB,KAA8B,CAAlC,EAAqC;MACnC,KAAK,IAAIE,EAAT,IAAerB,yCAAf,EACEqB;;MAGFrB,0CAAoBsB,KAApB;IACF;EACF,CA1BA;;EA4BAC,SAASC,IAAT,CAAcZ,gBAAd,CAA+B,eAA/B,EAAgDN,iBAAhD;EACAiB,SAASC,IAAT,CAAcZ,gBAAd,CAA+B,eAA/B,EAAgDC,eAAhD;AACF;;AAEA,IAAI,OAAOU,QAAP,KAAoB,WAAxB,EAAwB;EACtB,IAAIA,SAASE,UAAT,KAAwB,SAA5B,EACEvB,0CADF,KAGEqB,SAASX,gBAAT,CAA0B,kBAA1B,EAA8CV,uCAA9C;;AAIJ;;;;;;;AAKA,SAASwB,6CAAT,GAAS;EACP,KAAK,MAAM,CAACC,WAAD,CAAX,IAA4B7B,0CAA5B,EACE;EACA;EACA,IAAI,iBAAiB6B,WAAjB,IAAgC,CAACA,YAAYC,WAAjD,EACE9B,2CAAqBoB,MAArB,CAA4BS,WAA5B;AAGN;;AAEO,SAASE,yCAAT,CAA4BC,EAA5B,EAA0C;EAC/C;EACAC,sBAAsB;IACpBL,gDADoB,CAEpB;IACA;;IACA,IAAI5B,2CAAqBqB,IAArB,KAA8B,CAAlC,EACEW,KADF,KAGE9B,0CAAoBe,GAApB,CAAwBe,EAAxB;EAEJ,CATA;AAUF","names":["$bbed8b41f857bcc0$var$transitionsByElement","Map","$bbed8b41f857bcc0$var$transitionCallbacks","Set","$bbed8b41f857bcc0$var$setupGlobalEvents","window","isTransitionEvent","event","onTransitionStart","e","target","transitions","get","set","addEventListener","onTransitionEnd","once","add","propertyName","properties","delete","size","removeEventListener","cb","clear","document","body","readyState","$bbed8b41f857bcc0$var$cleanupDetachedElements","eventTarget","isConnected","$bbed8b41f857bcc0$export$24490316f764c430","fn","requestAnimationFrame"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\runAfterTransition.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet transitionsByElement = new Map<EventTarget, Set<string>>();\n\n// A list of callbacks to call once there are no transitioning elements.\nlet transitionCallbacks = new Set<() => void>();\n\nfunction setupGlobalEvents() {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  function isTransitionEvent(event: Event): event is TransitionEvent {\n    return 'propertyName' in event;\n  }\n\n  let onTransitionStart = (e: Event) => {\n    if (!isTransitionEvent(e) || !e.target) {\n      return;\n    }\n    // Add the transitioning property to the list for this element.\n    let transitions = transitionsByElement.get(e.target);\n    if (!transitions) {\n      transitions = new Set();\n      transitionsByElement.set(e.target, transitions);\n\n      // The transitioncancel event must be registered on the element itself, rather than as a global\n      // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n      // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n      e.target.addEventListener('transitioncancel', onTransitionEnd, {\n        once: true\n      });\n    }\n\n    transitions.add(e.propertyName);\n  };\n\n  let onTransitionEnd = (e: Event) => {\n    if (!isTransitionEvent(e) || !e.target) {\n      return;\n    }\n    // Remove property from list of transitioning properties.\n    let properties = transitionsByElement.get(e.target);\n    if (!properties) {\n      return;\n    }\n\n    properties.delete(e.propertyName);\n\n    // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n    if (properties.size === 0) {\n      e.target.removeEventListener('transitioncancel', onTransitionEnd);\n      transitionsByElement.delete(e.target);\n    }\n\n    // If no transitioning elements, call all of the queued callbacks.\n    if (transitionsByElement.size === 0) {\n      for (let cb of transitionCallbacks) {\n        cb();\n      }\n\n      transitionCallbacks.clear();\n    }\n  };\n\n  document.body.addEventListener('transitionrun', onTransitionStart);\n  document.body.addEventListener('transitionend', onTransitionEnd);\n}\n\nif (typeof document !== 'undefined') {\n  if (document.readyState !== 'loading') {\n    setupGlobalEvents();\n  } else {\n    document.addEventListener('DOMContentLoaded', setupGlobalEvents);\n  }\n}\n\n/**\n * Cleans up any elements that are no longer in the document.\n * This is necessary because we can't rely on transitionend events to fire\n * for elements that are removed from the document while transitioning.\n */\nfunction cleanupDetachedElements() {\n  for (const [eventTarget] of transitionsByElement) {\n    // Similar to `eventTarget instanceof Element && !eventTarget.isConnected`, but avoids\n    // the explicit instanceof check, since it may be different in different contexts.\n    if ('isConnected' in eventTarget && !eventTarget.isConnected) {\n      transitionsByElement.delete(eventTarget);\n    }\n  }\n}\n\nexport function runAfterTransition(fn: () => void): void {\n  // Wait one frame to see if an animation starts, e.g. a transition on mount.\n  requestAnimationFrame(() => {\n    cleanupDetachedElements();\n    // If no transitions are running, call the function immediately.\n    // Otherwise, add it to a list of callbacks to run at the end of the animation.\n    if (transitionsByElement.size === 0) {\n      fn();\n    } else {\n      transitionCallbacks.add(fn);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { nodeContains as $d4ee10de306f2510$export$4282f70798064fe0 } from \"./DOMFunctions.mjs\";\nimport { shadowDOM as $bJKXg$shadowDOM } from \"@react-stately/flags\"; // https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/ShadowTreeWalker.ts\n\nclass $dfc540311bf7f109$export$63eb3ababa9c55c4 {\n  get currentNode() {\n    return this._currentNode;\n  }\n\n  set currentNode(node) {\n    if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(this.root, node)) throw new Error('Cannot set currentNode to a node that is not contained by the root node.');\n    const walkers = [];\n    let curNode = node;\n    let currentWalkerCurrentNode = node;\n    this._currentNode = node;\n\n    while (curNode && curNode !== this.root) if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      const shadowRoot = curNode;\n\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n\n      walkers.push(walker);\n      walker.currentNode = currentWalkerCurrentNode;\n\n      this._currentSetFor.add(walker);\n\n      curNode = currentWalkerCurrentNode = shadowRoot.host;\n    } else curNode = curNode.parentNode;\n\n    const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n      acceptNode: this._acceptNode\n    });\n\n    walkers.push(walker);\n    walker.currentNode = currentWalkerCurrentNode;\n\n    this._currentSetFor.add(walker);\n\n    this._walkerStack = walkers;\n  }\n\n  get doc() {\n    return this._doc;\n  }\n\n  firstChild() {\n    let currentNode = this.currentNode;\n    let newNode = this.nextNode();\n\n    if (!(0, $d4ee10de306f2510$export$4282f70798064fe0)(currentNode, newNode)) {\n      this.currentNode = currentNode;\n      return null;\n    }\n\n    if (newNode) this.currentNode = newNode;\n    return newNode;\n  }\n\n  lastChild() {\n    let walker = this._walkerStack[0];\n    let newNode = walker.lastChild();\n    if (newNode) this.currentNode = newNode;\n    return newNode;\n  }\n\n  nextNode() {\n    const nextNode = this._walkerStack[0].nextNode();\n\n    if (nextNode) {\n      const shadowRoot = nextNode.shadowRoot;\n\n      if (shadowRoot) {\n        var _this_filter;\n\n        let nodeResult;\n        if (typeof this.filter === 'function') nodeResult = this.filter(nextNode);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) nodeResult = this.filter.acceptNode(nextNode);\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          this.currentNode = nextNode;\n          return nextNode;\n        } // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n\n\n        let newNode = this.nextNode();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      }\n\n      if (nextNode) this.currentNode = nextNode;\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.nextNode();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      } else return null;\n    }\n  }\n\n  previousNode() {\n    const currentWalker = this._walkerStack[0];\n\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n\n          let newNode = this.previousNode();\n          if (newNode) this.currentNode = newNode;\n          return newNode;\n        } else return null;\n      }\n\n      return null;\n    }\n\n    const previousNode = currentWalker.previousNode();\n\n    if (previousNode) {\n      const shadowRoot = previousNode.shadowRoot;\n\n      if (shadowRoot) {\n        var _this_filter;\n\n        let nodeResult;\n        if (typeof this.filter === 'function') nodeResult = this.filter(previousNode);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) nodeResult = this.filter.acceptNode(previousNode);\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          if (previousNode) this.currentNode = previousNode;\n          return previousNode;\n        } // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n\n\n        let newNode = this.lastChild();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      }\n\n      if (previousNode) this.currentNode = previousNode;\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.previousNode();\n        if (newNode) this.currentNode = newNode;\n        return newNode;\n      } else return null;\n    }\n  }\n  /**\n   * @deprecated\n   */\n\n\n  nextSibling() {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n    return null;\n  }\n  /**\n   * @deprecated\n   */\n\n\n  previousSibling() {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n    return null;\n  }\n  /**\n   * @deprecated\n   */\n\n\n  parentNode() {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n    return null;\n  }\n\n  constructor(doc, root, whatToShow, filter) {\n    this._walkerStack = [];\n    this._currentSetFor = new Set();\n\n    this._acceptNode = node => {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const shadowRoot = node.shadowRoot;\n\n        if (shadowRoot) {\n          const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n            acceptNode: this._acceptNode\n          });\n\n          this._walkerStack.unshift(walker);\n\n          return NodeFilter.FILTER_ACCEPT;\n        } else {\n          var _this_filter;\n\n          if (typeof this.filter === 'function') return this.filter(node);else if ((_this_filter = this.filter) === null || _this_filter === void 0 ? void 0 : _this_filter.acceptNode) return this.filter.acceptNode(node);else if (this.filter === null) return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    };\n\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter !== null && filter !== void 0 ? filter : null;\n    this.whatToShow = whatToShow !== null && whatToShow !== void 0 ? whatToShow : NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n\n    this._walkerStack.unshift(doc.createTreeWalker(root, whatToShow, this._acceptNode));\n\n    const shadowRoot = root.shadowRoot;\n\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(shadowRoot, this.whatToShow, {\n        acceptNode: this._acceptNode\n      });\n\n      this._walkerStack.unshift(walker);\n    }\n  }\n\n}\n\nfunction $dfc540311bf7f109$export$4d0f8be8b12a7ef6(doc, root, whatToShow, filter) {\n  if ((0, $bJKXg$shadowDOM)()) return new $dfc540311bf7f109$export$63eb3ababa9c55c4(doc, root, whatToShow, filter);\n  return doc.createTreeWalker(root, whatToShow, filter);\n}\n\nexport { $dfc540311bf7f109$export$63eb3ababa9c55c4 as ShadowTreeWalker, $dfc540311bf7f109$export$4d0f8be8b12a7ef6 as createShadowTreeWalker };","map":{"version":3,"mappings":"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","names":["$dfc540311bf7f109$export$63eb3ababa9c55c4","_currentNode","node","root","Error","walkers","curNode","currentWalkerCurrentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","shadowRoot","walker","_doc","createTreeWalker","whatToShow","acceptNode","_acceptNode","push","currentNode","_currentSetFor","add","host","parentNode","_walkerStack","firstChild","newNode","nextNode","lastChild","_this_filter","nodeResult","filter","NodeFilter","FILTER_ACCEPT","length","shift","previousNode","currentWalker","has","delete","nextSibling","previousSibling","constructor","doc","Set","ELEMENT_NODE","unshift","FILTER_SKIP","SHOW_ALL","$dfc540311bf7f109$export$4d0f8be8b12a7ef6"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\shadowdom\\ShadowTreeWalker.ts"],"sourcesContent":["// https://github.com/microsoft/tabster/blob/a89fc5d7e332d48f68d03b1ca6e344489d1c3898/src/Shadowdomize/ShadowTreeWalker.ts\n\nimport {nodeContains} from './DOMFunctions';\nimport {shadowDOM} from '@react-stately/flags';\n\nexport class ShadowTreeWalker implements TreeWalker {\n  public readonly filter: NodeFilter | null;\n  public readonly root: Node;\n  public readonly whatToShow: number;\n\n  private _doc: Document;\n  private _walkerStack: Array<TreeWalker> = [];\n  private _currentNode: Node;\n  private _currentSetFor: Set<TreeWalker> = new Set();\n\n  constructor(\n      doc: Document,\n      root: Node,\n      whatToShow?: number,\n      filter?: NodeFilter | null\n    ) {\n    this._doc = doc;\n    this.root = root;\n    this.filter = filter ?? null;\n    this.whatToShow = whatToShow ?? NodeFilter.SHOW_ALL;\n    this._currentNode = root;\n\n    this._walkerStack.unshift(\n      doc.createTreeWalker(root, whatToShow, this._acceptNode)\n    );\n\n    const shadowRoot = (root as Element).shadowRoot;\n\n    if (shadowRoot) {\n      const walker = this._doc.createTreeWalker(\n        shadowRoot,\n        this.whatToShow,\n        {acceptNode: this._acceptNode}\n      );\n\n      this._walkerStack.unshift(walker);\n    }\n  }\n\n  private _acceptNode = (node: Node): number => {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const shadowRoot = (node as Element).shadowRoot;\n\n      if (shadowRoot) {\n        const walker = this._doc.createTreeWalker(\n          shadowRoot,\n          this.whatToShow,\n          {acceptNode: this._acceptNode}\n        );\n\n        this._walkerStack.unshift(walker);\n\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        if (typeof this.filter === 'function') {\n          return this.filter(node);\n        } else if (this.filter?.acceptNode) {\n          return this.filter.acceptNode(node);\n        } else if (this.filter === null) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  };\n\n  public get currentNode(): Node {\n    return this._currentNode;\n  }\n\n  public set currentNode(node: Node) {\n    if (!nodeContains(this.root, node)) {\n      throw new Error(\n        'Cannot set currentNode to a node that is not contained by the root node.'\n      );\n    }\n\n    const walkers: TreeWalker[] = [];\n    let curNode: Node | null | undefined = node;\n    let currentWalkerCurrentNode = node;\n\n    this._currentNode = node;\n\n    while (curNode && curNode !== this.root) {\n      if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        const shadowRoot = curNode as ShadowRoot;\n\n        const walker = this._doc.createTreeWalker(\n          shadowRoot,\n          this.whatToShow,\n          {acceptNode: this._acceptNode}\n        );\n\n        walkers.push(walker);\n\n        walker.currentNode = currentWalkerCurrentNode;\n\n        this._currentSetFor.add(walker);\n\n        curNode = currentWalkerCurrentNode = shadowRoot.host;\n      } else {\n        curNode = curNode.parentNode;\n      }\n    }\n\n    const walker = this._doc.createTreeWalker(\n      this.root,\n      this.whatToShow,\n      {acceptNode: this._acceptNode}\n    );\n\n    walkers.push(walker);\n\n    walker.currentNode = currentWalkerCurrentNode;\n\n    this._currentSetFor.add(walker);\n\n    this._walkerStack = walkers;\n  }\n\n  public get doc(): Document {\n    return this._doc;\n  }\n\n  public firstChild(): Node | null {\n    let currentNode = this.currentNode;\n    let newNode = this.nextNode();\n    if (!nodeContains(currentNode, newNode)) {\n      this.currentNode = currentNode;\n      return null;\n    }\n    if (newNode) {\n      this.currentNode = newNode;\n    }\n    return newNode;\n  }\n\n  public lastChild(): Node | null {\n    let walker = this._walkerStack[0];\n    let newNode = walker.lastChild();\n    if (newNode) {\n      this.currentNode = newNode;\n    }\n    return newNode;\n  }\n\n  public nextNode(): Node | null {\n    const nextNode = this._walkerStack[0].nextNode();\n\n    if (nextNode) {\n      const shadowRoot = (nextNode as Element).shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult: number | undefined;\n\n        if (typeof this.filter === 'function') {\n          nodeResult = this.filter(nextNode);\n        } else if (this.filter?.acceptNode) {\n          nodeResult = this.filter.acceptNode(nextNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          this.currentNode = nextNode;\n          return nextNode;\n        }\n\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.nextNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      }\n\n      if (nextNode) {\n        this.currentNode = nextNode;\n      }\n      return nextNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.nextNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  public previousNode(): Node | null {\n    const currentWalker = this._walkerStack[0];\n\n    if (currentWalker.currentNode === currentWalker.root) {\n      if (this._currentSetFor.has(currentWalker)) {\n        this._currentSetFor.delete(currentWalker);\n\n        if (this._walkerStack.length > 1) {\n          this._walkerStack.shift();\n          let newNode = this.previousNode();\n          if (newNode) {\n            this.currentNode = newNode;\n          }\n          return newNode;\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    }\n\n    const previousNode = currentWalker.previousNode();\n\n    if (previousNode) {\n      const shadowRoot = (previousNode as Element).shadowRoot;\n\n      if (shadowRoot) {\n        let nodeResult: number | undefined;\n\n        if (typeof this.filter === 'function') {\n          nodeResult = this.filter(previousNode);\n        } else if (this.filter?.acceptNode) {\n          nodeResult = this.filter.acceptNode(previousNode);\n        }\n\n        if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n          if (previousNode) {\n            this.currentNode = previousNode;\n          }\n          return previousNode;\n        }\n\n        // _acceptNode should have added new walker for this shadow,\n        // go in recursively.\n        let newNode = this.lastChild();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      }\n\n      if (previousNode) {\n        this.currentNode = previousNode;\n      }\n      return previousNode;\n    } else {\n      if (this._walkerStack.length > 1) {\n        this._walkerStack.shift();\n\n        let newNode = this.previousNode();\n        if (newNode) {\n          this.currentNode = newNode;\n        }\n        return newNode;\n      } else {\n        return null;\n      }\n    }\n  }\n\n    /**\n     * @deprecated\n     */\n  public nextSibling(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n\n    /**\n     * @deprecated\n     */\n  public previousSibling(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n\n    /**\n     * @deprecated\n     */\n  public parentNode(): Node | null {\n    // if (__DEV__) {\n    //     throw new Error(\"Method not implemented.\");\n    // }\n\n    return null;\n  }\n}\n\n/**\n * ShadowDOM safe version of document.createTreeWalker.\n */\nexport function createShadowTreeWalker(\n    doc: Document,\n    root: Node,\n    whatToShow?: number,\n    filter?: NodeFilter | null\n): TreeWalker {\n  if (shadowDOM()) {\n    return new ShadowTreeWalker(doc, root, whatToShow, filter);\n  }\n  return doc.createTreeWalker(root, whatToShow, filter);\n}\n"]},"metadata":{},"sourceType":"module"}
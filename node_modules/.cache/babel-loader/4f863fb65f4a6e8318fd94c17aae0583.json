{"ast":null,"code":"import { useGlobalListeners as $AWxnT$useGlobalListeners, getOwnerDocument as $AWxnT$getOwnerDocument, nodeContains as $AWxnT$nodeContains } from \"@react-aria/utils\";\nimport { useState as $AWxnT$useState, useRef as $AWxnT$useRef, useEffect as $AWxnT$useEffect, useMemo as $AWxnT$useMemo } from \"react\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\n\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\n\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true; // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n\n  setTimeout(() => {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\n\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n  if (e.pointerType === 'touch') $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\n\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n  if (typeof document === 'undefined') return;\n  if (typeof PointerEvent !== 'undefined') document.addEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);else if (process.env.NODE_ENV === 'test') document.addEventListener('touchend', $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n  $6179b936705e76d3$var$hoverCount++;\n  return () => {\n    $6179b936705e76d3$var$hoverCount--;\n    if ($6179b936705e76d3$var$hoverCount > 0) return;\n    if (typeof PointerEvent !== 'undefined') document.removeEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);else if (process.env.NODE_ENV === 'test') document.removeEventListener('touchend', $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n  };\n}\n\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n  let {\n    onHoverStart: onHoverStart,\n    onHoverChange: onHoverChange,\n    onHoverEnd: onHoverEnd,\n    isDisabled: isDisabled\n  } = props;\n  let [isHovered, setHovered] = (0, $AWxnT$useState)(false);\n  let state = (0, $AWxnT$useRef)({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: '',\n    target: null\n  }).current;\n  (0, $AWxnT$useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n  let {\n    addGlobalListener: addGlobalListener,\n    removeAllGlobalListeners: removeAllGlobalListeners\n  } = (0, $AWxnT$useGlobalListeners)();\n  let {\n    hoverProps: hoverProps,\n    triggerHoverEnd: triggerHoverEnd\n  } = (0, $AWxnT$useMemo)(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) return;\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target; // When an element that is hovered over is removed, no pointerleave event is fired by the browser,\n      // even though the originally hovered target may have shrunk in size so it is no longer hovered.\n      // However, a pointerover event will be fired on the new target the mouse is over.\n      // In Chrome this happens immediately. In Safari and Firefox, it happens upon moving the mouse one pixel.\n\n      addGlobalListener((0, $AWxnT$getOwnerDocument)(event.target), 'pointerover', e => {\n        if (state.isHovered && state.target && !(0, $AWxnT$nodeContains)(state.target, e.target)) triggerHoverEnd(e, e.pointerType);\n      }, {\n        capture: true\n      });\n      if (onHoverStart) onHoverStart({\n        type: 'hoverstart',\n        target: target,\n        pointerType: pointerType\n      });\n      if (onHoverChange) onHoverChange(true);\n      setHovered(true);\n    };\n\n    let triggerHoverEnd = (event, pointerType) => {\n      let target = state.target;\n      state.pointerType = '';\n      state.target = null;\n      if (pointerType === 'touch' || !state.isHovered || !target) return;\n      state.isHovered = false;\n      removeAllGlobalListeners();\n      if (onHoverEnd) onHoverEnd({\n        type: 'hoverend',\n        target: target,\n        pointerType: pointerType\n      });\n      if (onHoverChange) onHoverChange(false);\n      setHovered(false);\n    };\n\n    let hoverProps = {};\n\n    if (typeof PointerEvent !== 'undefined') {\n      hoverProps.onPointerEnter = e => {\n        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') return;\n        triggerHoverStart(e, e.pointerType);\n      };\n\n      hoverProps.onPointerLeave = e => {\n        if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      hoverProps.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n\n      hoverProps.onMouseEnter = e => {\n        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, 'mouse');\n        state.ignoreEmulatedMouseEvents = false;\n      };\n\n      hoverProps.onMouseLeave = e => {\n        if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, 'mouse');\n      };\n    }\n\n    return {\n      hoverProps: hoverProps,\n      triggerHoverEnd: triggerHoverEnd\n    };\n  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state, addGlobalListener, removeAllGlobalListeners]);\n  (0, $AWxnT$useEffect)(() => {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) triggerHoverEnd({\n      currentTarget: state.target\n    }, state.pointerType); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n  return {\n    hoverProps: hoverProps,\n    isHovered: isHovered\n  };\n}\n\nexport { $6179b936705e76d3$export$ae780daf29e6d456 as useHover };","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AAiBA;AACA;AACA;;AACA,IAAIA,wDAAkC,KAAtC;AACA,IAAIC,mCAAa,CAAjB;;AAEA,SAASC,wDAAT,GAAS;EACPF,wDAAkC,IAAlC,CADO,CAGP;EACA;EACA;EACA;;EACAG,WAAW;IACTH,wDAAkC,KAAlC;EACF,CAFA,EAEG,EAFH;AAGF;;AAEA,SAASI,8CAAT,CAAkCC,CAAlC,EAAmC;EACjC,IAAIA,EAAEC,WAAF,KAAkB,OAAtB,EACEJ;AAEJ;;AAEA,SAASK,4CAAT,GAAS;EACP,IAAI,OAAOC,QAAP,KAAoB,WAAxB,EACE;EAGF,IAAI,OAAOC,YAAP,KAAwB,WAA5B,EACED,SAASE,gBAAT,CAA0B,WAA1B,EAAuCN,8CAAvC,EADF,KAEO,IAAIO,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EACLL,SAASE,gBAAT,CAA0B,UAA1B,EAAsCR,wDAAtC;EAGFD;EACA,OAAO;IACLA;IACA,IAAIA,mCAAa,CAAjB,EACE;IAGF,IAAI,OAAOQ,YAAP,KAAwB,WAA5B,EACED,SAASM,mBAAT,CAA6B,WAA7B,EAA0CV,8CAA1C,EADF,KAEO,IAAIO,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EACLL,SAASM,mBAAT,CAA6B,UAA7B,EAAyCZ,wDAAzC;EAEJ,CAXA;AAYF;;AAMO,SAASa,yCAAT,CAAkBC,KAAlB,EAAmC;EACxC,IAAI;IAAAC,cACFA,YADE;IACUC,eACZA,aAFE;IAEWC,YACbA,UAHE;IAGQC,YACVA;EAJE,IAKAJ,KALJ;EAOA,IAAI,CAACK,SAAD,EAAYC,UAAZ,IAA0B,qBAAS,KAAT,CAA9B;EACA,IAAIC,QAAQ,mBAAO;IACjBF,WAAW,KADM;IAEjBG,2BAA2B,KAFV;IAGjBlB,aAAa,EAHI;IAIjBmB,QAAQ;EAJS,CAAP,EAKTC,OALH;EAOA,sBAAUnB,4CAAV,EAAkC,EAAlC;EACA,IAAI;IAAAoB,mBAACA,iBAAD;IAAkBC,0BAAEA;EAApB,IAAgD,gCAApD;EAEA,IAAI;IAAAC,YAACA,UAAD;IAAWC,iBAAEA;EAAb,IAAgC,oBAAQ;IAC1C,IAAIC,oBAAoB,CAACC,KAAD,EAAQ1B,WAAR,KAAQ;MAC9BiB,MAAMjB,WAAN,GAAoBA,WAApB;MACA,IAAIc,cAAcd,gBAAgB,OAA9B,IAAyCiB,MAAMF,SAA/C,IAA4D,CAACW,MAAMC,aAAN,CAAoBC,QAApB,CAA6BF,MAAMP,MAAnC,CAAjE,EACE;MAGFF,MAAMF,SAAN,GAAkB,IAAlB;MACA,IAAII,SAASO,MAAMC,aAAnB;MACAV,MAAME,MAAN,GAAeA,MAAf,CAR8B,CAU9B;MACA;MACA;MACA;;MACAE,kBAAkB,6BAAiBK,MAAMP,MAAvB,CAAlB,EAAkD,aAAlD,EAAiEpB;QAC/D,IAAIkB,MAAMF,SAAN,IAAmBE,MAAME,MAAzB,IAAmC,CAAC,yBAAaF,MAAME,MAAnB,EAA2BpB,EAAEoB,MAA7B,CAAxC,EACEK,gBAAgBzB,CAAhB,EAAmBA,EAAEC,WAArB;MAEJ,CAJA,EAIG;QAAC6B,SAAS;MAAV,CAJH;MAMA,IAAIlB,YAAJ,EACEA,aAAa;QACXmB,MAAM,YADK;gBAEXX,MAFW;qBAGXnB;MAHW,CAAb;MAOF,IAAIY,aAAJ,EACEA,cAAc,IAAd;MAGFI,WAAW,IAAX;IACF,CAjCA;;IAmCA,IAAIQ,kBAAkB,CAACE,KAAD,EAAQ1B,WAAR,KAAQ;MAC5B,IAAImB,SAASF,MAAME,MAAnB;MACAF,MAAMjB,WAAN,GAAoB,EAApB;MACAiB,MAAME,MAAN,GAAe,IAAf;MAEA,IAAInB,gBAAgB,OAAhB,IAA2B,CAACiB,MAAMF,SAAlC,IAA+C,CAACI,MAApD,EACE;MAGFF,MAAMF,SAAN,GAAkB,KAAlB;MACAO;MAEA,IAAIT,UAAJ,EACEA,WAAW;QACTiB,MAAM,UADG;gBAETX,MAFS;qBAGTnB;MAHS,CAAX;MAOF,IAAIY,aAAJ,EACEA,cAAc,KAAd;MAGFI,WAAW,KAAX;IACF,CAzBA;;IA2BA,IAAIO,aAA4B,EAAhC;;IAEA,IAAI,OAAOpB,YAAP,KAAwB,WAA5B,EAAyC;MACvCoB,WAAWQ,cAAX,GAA6BhC,CAAD,IAAC;QAC3B,IAAIL,yDAAmCK,EAAEC,WAAF,KAAkB,OAAzD,EACE;QAGFyB,kBAAkB1B,CAAlB,EAAqBA,EAAEC,WAAvB;MACF,CANA;;MAQAuB,WAAWS,cAAX,GAA6BjC,CAAD,IAAC;QAC3B,IAAI,CAACe,UAAD,IAAef,EAAE4B,aAAF,CAAgBC,QAAhB,CAAyB7B,EAAEoB,MAA3B,CAAnB,EACEK,gBAAgBzB,CAAhB,EAAmBA,EAAEC,WAArB;MAEJ,CAJA;IAKF,CAdA,MAcO,IAAIK,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EAAqC;MAC1CgB,WAAWU,YAAX,GAA0B;QACxBhB,MAAMC,yBAAN,GAAkC,IAAlC;MACF,CAFA;;MAIAK,WAAWW,YAAX,GAA2BnC,CAAD,IAAC;QACzB,IAAI,CAACkB,MAAMC,yBAAP,IAAoC,CAACxB,qDAAzC,EACE+B,kBAAkB1B,CAAlB,EAAqB,OAArB;QAGFkB,MAAMC,yBAAN,GAAkC,KAAlC;MACF,CANA;;MAQAK,WAAWY,YAAX,GAA2BpC,CAAD,IAAC;QACzB,IAAI,CAACe,UAAD,IAAef,EAAE4B,aAAF,CAAgBC,QAAhB,CAAyB7B,EAAEoB,MAA3B,CAAnB,EACEK,gBAAgBzB,CAAhB,EAAmB,OAAnB;MAEJ,CAJA;IAKF;;IACA,OAAO;kBAACwB,UAAD;uBAAaC;IAAb,CAAP;EACF,CAnGoC,EAmGjC,CAACb,YAAD,EAAeC,aAAf,EAA8BC,UAA9B,EAA0CC,UAA1C,EAAsDG,KAAtD,EAA6DI,iBAA7D,EAAgFC,wBAAhF,CAnGiC,CAApC;EAqGA,sBAAU;IACR;IACA;IACA,IAAIR,UAAJ,EACEU,gBAAgB;MAACG,eAAeV,MAAME;IAAtB,CAAhB,EAA+CF,MAAMjB,WAArD,EAJM,CAMV;EACA,CAPA,EAOG,CAACc,UAAD,CAPH;EASA,OAAO;gBACLS,UADK;eAELR;EAFK,CAAP;AAIF","names":["$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents","$6179b936705e76d3$var$hoverCount","$6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents","setTimeout","$6179b936705e76d3$var$handleGlobalPointerEvent","e","pointerType","$6179b936705e76d3$var$setupGlobalTouchEvents","document","PointerEvent","addEventListener","process","env","NODE_ENV","removeEventListener","$6179b936705e76d3$export$ae780daf29e6d456","props","onHoverStart","onHoverChange","onHoverEnd","isDisabled","isHovered","setHovered","state","ignoreEmulatedMouseEvents","target","current","addGlobalListener","removeAllGlobalListeners","hoverProps","triggerHoverEnd","triggerHoverStart","event","currentTarget","contains","capture","type","onPointerEnter","onPointerLeave","onTouchStart","onMouseEnter","onMouseLeave"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\useHover.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {DOMAttributes, HoverEvents} from '@react-types/shared';\nimport {getOwnerDocument, nodeContains, useGlobalListeners} from '@react-aria/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface HoverProps extends HoverEvents {\n  /** Whether the hover events should be disabled. */\n  isDisabled?: boolean\n}\n\nexport interface HoverResult {\n  /** Props to spread on the target element. */\n  hoverProps: DOMAttributes,\n  isHovered: boolean\n}\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet globalIgnoreEmulatedMouseEvents = false;\nlet hoverCount = 0;\n\nfunction setGlobalIgnoreEmulatedMouseEvents() {\n  globalIgnoreEmulatedMouseEvents = true;\n\n  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n  setTimeout(() => {\n    globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\n\nfunction handleGlobalPointerEvent(e) {\n  if (e.pointerType === 'touch') {\n    setGlobalIgnoreEmulatedMouseEvents();\n  }\n}\n\nfunction setupGlobalTouchEvents() {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (typeof PointerEvent !== 'undefined') {\n    document.addEventListener('pointerup', handleGlobalPointerEvent);\n  } else if (process.env.NODE_ENV === 'test') {\n    document.addEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n  }\n\n  hoverCount++;\n  return () => {\n    hoverCount--;\n    if (hoverCount > 0) {\n      return;\n    }\n\n    if (typeof PointerEvent !== 'undefined') {\n      document.removeEventListener('pointerup', handleGlobalPointerEvent);\n    } else if (process.env.NODE_ENV === 'test') {\n      document.removeEventListener('touchend', setGlobalIgnoreEmulatedMouseEvents);\n    }\n  };\n}\n\n/**\n * Handles pointer hover interactions for an element. Normalizes behavior\n * across browsers and platforms, and ignores emulated mouse events on touch devices.\n */\nexport function useHover(props: HoverProps): HoverResult {\n  let {\n    onHoverStart,\n    onHoverChange,\n    onHoverEnd,\n    isDisabled\n  } = props;\n\n  let [isHovered, setHovered] = useState(false);\n  let state = useRef({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: '',\n    target: null\n  }).current;\n\n  useEffect(setupGlobalTouchEvents, []);\n  let {addGlobalListener, removeAllGlobalListeners} = useGlobalListeners();\n\n  let {hoverProps, triggerHoverEnd} = useMemo(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      state.pointerType = pointerType;\n      if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) {\n        return;\n      }\n\n      state.isHovered = true;\n      let target = event.currentTarget;\n      state.target = target;\n\n      // When an element that is hovered over is removed, no pointerleave event is fired by the browser,\n      // even though the originally hovered target may have shrunk in size so it is no longer hovered.\n      // However, a pointerover event will be fired on the new target the mouse is over.\n      // In Chrome this happens immediately. In Safari and Firefox, it happens upon moving the mouse one pixel.\n      addGlobalListener(getOwnerDocument(event.target), 'pointerover', e => {\n        if (state.isHovered && state.target && !nodeContains(state.target, e.target as Element)) {\n          triggerHoverEnd(e, e.pointerType);\n        }\n      }, {capture: true});\n\n      if (onHoverStart) {\n        onHoverStart({\n          type: 'hoverstart',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(true);\n      }\n\n      setHovered(true);\n    };\n\n    let triggerHoverEnd = (event, pointerType) => {\n      let target = state.target;\n      state.pointerType = '';\n      state.target = null;\n\n      if (pointerType === 'touch' || !state.isHovered || !target) {\n        return;\n      }\n\n      state.isHovered = false;\n      removeAllGlobalListeners();\n\n      if (onHoverEnd) {\n        onHoverEnd({\n          type: 'hoverend',\n          target,\n          pointerType\n        });\n      }\n\n      if (onHoverChange) {\n        onHoverChange(false);\n      }\n\n      setHovered(false);\n    };\n\n    let hoverProps: DOMAttributes = {};\n\n    if (typeof PointerEvent !== 'undefined') {\n      hoverProps.onPointerEnter = (e) => {\n        if (globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') {\n          return;\n        }\n\n        triggerHoverStart(e, e.pointerType);\n      };\n\n      hoverProps.onPointerLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, e.pointerType);\n        }\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      hoverProps.onTouchStart = () => {\n        state.ignoreEmulatedMouseEvents = true;\n      };\n\n      hoverProps.onMouseEnter = (e) => {\n        if (!state.ignoreEmulatedMouseEvents && !globalIgnoreEmulatedMouseEvents) {\n          triggerHoverStart(e, 'mouse');\n        }\n\n        state.ignoreEmulatedMouseEvents = false;\n      };\n\n      hoverProps.onMouseLeave = (e) => {\n        if (!isDisabled && e.currentTarget.contains(e.target as Element)) {\n          triggerHoverEnd(e, 'mouse');\n        }\n      };\n    }\n    return {hoverProps, triggerHoverEnd};\n  }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state, addGlobalListener, removeAllGlobalListeners]);\n\n  useEffect(() => {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) {\n      triggerHoverEnd({currentTarget: state.target}, state.pointerType);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n\n  return {\n    hoverProps,\n    isHovered\n  };\n}\n"]},"metadata":{},"sourceType":"module"}
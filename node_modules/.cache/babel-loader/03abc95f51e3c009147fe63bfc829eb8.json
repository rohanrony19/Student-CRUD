{"ast":null,"code":"import { useState as $3whtM$useState, useRef as $3whtM$useRef, useEffect as $3whtM$useEffect, useCallback as $3whtM$useCallback } from \"react\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $458b0a5536c1a7cf$export$40bfa8c7b0832715(value, defaultValue, onChange) {\n  let [stateValue, setStateValue] = (0, $3whtM$useState)(value || defaultValue);\n  let isControlledRef = (0, $3whtM$useRef)(value !== undefined);\n  let isControlled = value !== undefined;\n  (0, $3whtM$useEffect)(() => {\n    let wasControlled = isControlledRef.current;\n    if (wasControlled !== isControlled && process.env.NODE_ENV !== 'production') console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n    isControlledRef.current = isControlled;\n  }, [isControlled]);\n  let currentValue = isControlled ? value : stateValue;\n  let setValue = (0, $3whtM$useCallback)(function (value) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    let onChangeCaller = function (value) {\n      if (onChange) {\n        for (var _len2 = arguments.length, onChangeArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          onChangeArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        if (!Object.is(currentValue, value)) onChange(value, ...onChangeArgs);\n      }\n\n      if (!isControlled) // If uncontrolled, mutate the currentValue local variable so that\n        // calling setState multiple times with the same value only emits onChange once.\n        // We do not use a ref for this because we specifically _do_ want the value to\n        // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        currentValue = value;\n    };\n\n    if (typeof value === 'function') {\n      if (process.env.NODE_ENV !== 'production') console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320'); // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n\n      let updateFunction = function (oldValue) {\n        for (var _len3 = arguments.length, functionArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          functionArgs[_key3 - 1] = arguments[_key3];\n        }\n\n        let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) return interceptedValue;\n        return oldValue;\n      };\n\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) setStateValue(value);\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, currentValue, onChange]);\n  return [currentValue, setValue];\n}\n\nexport { $458b0a5536c1a7cf$export$40bfa8c7b0832715 as useControlledState };","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;AAgBO,SAASA,yCAAT,CAAsCC,KAAtC,EAAgDC,YAAhD,EAAiEC,QAAjE,EAA0G;EAC/G,IAAI,CAACC,UAAD,EAAaC,aAAb,IAA8B,qBAASJ,SAASC,YAAlB,CAAlC;EAEA,IAAII,kBAAkB,mBAAOL,UAAUM,SAAjB,CAAtB;EACA,IAAIC,eAAeP,UAAUM,SAA7B;EACA,sBAAU;IACR,IAAIE,gBAAgBH,gBAAgBI,OAApC;IACA,IAAID,kBAAkBD,YAAlB,IAAkCG,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA/D,EACEC,QAAQC,IAAR,CAAc,kCAAiCN,gBAAgB,YAAhB,GAA+B,cAAe,OAAMD,eAAe,YAAf,GAA8B,cAAe,GAAhJ;IAEFF,gBAAgBI,OAAhB,GAA0BF,YAA1B;EACF,CANA,EAMG,CAACA,YAAD,CANH;EAQA,IAAIQ,eAAeR,eAAeP,KAAf,GAAuBG,UAA1C;EACA,IAAIa,WAAW,wBAAY,UAAChB,KAAD,EAAW;IAAA;MAAAiB;IAAA;;IACpC,IAAIC,iBAAiB,UAAClB,KAAD,EAAW;MAC9B,IAAIE,QAAJ,EACE;QAAA,mCAF4BiB,YAE5B;UAF4BA,YAE5B;QAAA;;QAAA,IAAI,CAACC,OAAOC,EAAP,CAAUN,YAAV,EAAwBf,KAAxB,CAAL,EACEE,SAASF,KAAT,EAAS,GAAUmB,YAAnB;MACF;;MAEF,IAAI,CAACZ,YAAL,EACE;QACA;QACA;QACA;QACA;QACAQ,eAAef,KAAf;IAEJ,CAdA;;IAgBA,IAAI,OAAOA,KAAP,KAAiB,UAArB,EAAiC;MAC/B,IAAIU,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EACEC,QAAQC,IAAR,CAAa,2HAAb,EAF6B,CAI/B;MACA;MACA;MACA;MACA;;MACA,IAAIQ,iBAAiB,UAACC,QAAD,EAAc;QAAA;UAAAC;QAAA;;QACjC,IAAIC,mBAAmBzB,MAAMO,eAAeQ,YAAf,GAA8BQ,QAApC,EAAoC,GAAaC,YAAjD,CAAvB;QACAN,eAAeO,gBAAf,EAAe,GAAqBR,IAApC;QACA,IAAI,CAACV,YAAL,EACE,OAAOkB,gBAAP;QAEF,OAAOF,QAAP;MACF,CAPA;;MAQAnB,cAAckB,cAAd;IACF,CAlBA,MAkBO;MACL,IAAI,CAACf,YAAL,EACEH,cAAcJ,KAAd;MAEFkB,eAAelB,KAAf,EAAe,GAAUiB,IAAzB;IACF;EACF,CAzCe,EAyCZ,CAACV,YAAD,EAAeQ,YAAf,EAA6Bb,QAA7B,CAzCY,CAAf;EA2CA,OAAO,CAACa,YAAD,EAAeC,QAAf,CAAP;AACF","names":["$458b0a5536c1a7cf$export$40bfa8c7b0832715","value","defaultValue","onChange","stateValue","setStateValue","isControlledRef","undefined","isControlled","wasControlled","current","process","env","NODE_ENV","console","warn","currentValue","setValue","args","onChangeCaller","onChangeArgs","Object","is","updateFunction","oldValue","functionArgs","interceptedValue"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-stately\\utils\\dist\\packages\\@react-stately\\utils\\src\\useControlledState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useEffect, useRef, useState} from 'react';\n\nexport function useControlledState<T, C = T>(value: Exclude<T, undefined>, defaultValue: Exclude<T, undefined> | undefined, onChange?: (v: C, ...args: any[]) => void): [T, (value: T, ...args: any[]) => void];\nexport function useControlledState<T, C = T>(value: Exclude<T, undefined> | undefined, defaultValue: Exclude<T, undefined>, onChange?: (v: C, ...args: any[]) => void): [T, (value: T, ...args: any[]) => void];\nexport function useControlledState<T, C = T>(value: T, defaultValue: T, onChange?: (v: C, ...args: any[]) => void): [T, (value: T, ...args: any[]) => void] {\n  let [stateValue, setStateValue] = useState(value || defaultValue);\n\n  let isControlledRef = useRef(value !== undefined);\n  let isControlled = value !== undefined;\n  useEffect(() => {\n    let wasControlled = isControlledRef.current;\n    if (wasControlled !== isControlled && process.env.NODE_ENV !== 'production') {\n      console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n    }\n    isControlledRef.current = isControlled;\n  }, [isControlled]);\n\n  let currentValue = isControlled ? value : stateValue;\n  let setValue = useCallback((value, ...args) => {\n    let onChangeCaller = (value, ...onChangeArgs) => {\n      if (onChange) {\n        if (!Object.is(currentValue, value)) {\n          onChange(value, ...onChangeArgs);\n        }\n      }\n      if (!isControlled) {\n        // If uncontrolled, mutate the currentValue local variable so that\n        // calling setState multiple times with the same value only emits onChange once.\n        // We do not use a ref for this because we specifically _do_ want the value to\n        // reset every render, and assigning to a ref in render breaks aborted suspended renders.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        currentValue = value;\n      }\n    };\n\n    if (typeof value === 'function') {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320');\n      }\n      // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n      // when someone using useControlledState calls setControlledState(myFunc)\n      // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n      // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n      // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n      let updateFunction = (oldValue, ...functionArgs) => {\n        let interceptedValue = value(isControlled ? currentValue : oldValue, ...functionArgs);\n        onChangeCaller(interceptedValue, ...args);\n        if (!isControlled) {\n          return interceptedValue;\n        }\n        return oldValue;\n      };\n      setStateValue(updateFunction);\n    } else {\n      if (!isControlled) {\n        setStateValue(value);\n      }\n      onChangeCaller(value, ...args);\n    }\n  }, [isControlled, currentValue, onChange]);\n\n  return [currentValue, setValue];\n}\n"]},"metadata":{},"sourceType":"module"}
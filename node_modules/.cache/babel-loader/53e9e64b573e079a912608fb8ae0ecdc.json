{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n* Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n*/\nfunction $9446cca9a3875146$export$7d15b64cf5a3a4c4(value) {\n  let min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nfunction $9446cca9a3875146$export$e1a7b8e69ef6c52f(value, step) {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf('.');\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n\n  return roundedValue;\n}\n\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n  min = Number(min);\n  max = Number(max);\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue = $9446cca9a3875146$export$e1a7b8e69ef6c52f(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) snappedValue = min;else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor($9446cca9a3875146$export$e1a7b8e69ef6c52f((max - min) / step, step)) * step;\n  } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor($9446cca9a3875146$export$e1a7b8e69ef6c52f(max / step, step)) * step; // correct floating point behavior by rounding to step precision\n\n\n  snappedValue = $9446cca9a3875146$export$e1a7b8e69ef6c52f(snappedValue, step);\n  return snappedValue;\n}\n\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits) {\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  const pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}\n\nexport { $9446cca9a3875146$export$7d15b64cf5a3a4c4 as clamp, $9446cca9a3875146$export$e1a7b8e69ef6c52f as roundToStepPrecision, $9446cca9a3875146$export$cb6e0bb50bc19463 as snapValueToStep, $9446cca9a3875146$export$b6268554fba451f as toFixedNumber };","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;AAYA;;;AAGO,SAASA,yCAAT,CAAeC,KAAf,EAA6E;EAAA,IAA/CC,GAA+C,uEAAjC,CAACC,QAAgC;EAAA,IAAtBC,GAAsB,uEAARD,QAAQ;EAClF,IAAIE,WAAWC,KAAKJ,GAAL,CAASI,KAAKF,GAAL,CAASH,KAAT,EAAgBC,GAAhB,CAAT,EAA+BE,GAA/B,CAAf;EACA,OAAOC,QAAP;AACF;;AAEO,SAASE,yCAAT,CAA8BN,KAA9B,EAA6CO,IAA7C,EAAyD;EAC9D,IAAIC,eAAeR,KAAnB;EACA,IAAIS,aAAaF,KAAKG,QAAL,EAAjB;EACA,IAAIC,aAAaF,WAAWG,OAAX,CAAmB,GAAnB,CAAjB;EACA,IAAIC,YAAYF,cAAc,CAAd,GAAkBF,WAAWK,MAAX,GAAoBH,UAAtC,GAAmD,CAAnE;;EACA,IAAIE,YAAY,CAAhB,EAAmB;IACjB,IAAIE,MAAMV,KAAKU,GAAL,CAAS,EAAT,EAAaF,SAAb,CAAV;IACAL,eAAeH,KAAKW,KAAL,CAAWR,eAAeO,GAA1B,IAAiCA,GAAhD;EACF;;EACA,OAAOP,YAAP;AACF;;AAEO,SAASS,yCAAT,CAAyBjB,KAAzB,EAAwCC,GAAxC,EAAiEE,GAAjE,EAA0FI,IAA1F,EAAsG;EAC3GN,MAAMiB,OAAOjB,GAAP,CAAN;EACAE,MAAMe,OAAOf,GAAP,CAAN;EACA,IAAIgB,YAAa,CAACnB,SAASoB,MAAMnB,GAAN,IAAa,CAAb,GAAiBA,GAA1B,CAAD,IAAmCM,IAApD;EACA,IAAIc,eAAef,0CAAqBD,KAAKiB,GAAL,CAASH,SAAT,IAAsB,CAAtB,IAA2BZ,IAA3B,GACpCP,QAAQK,KAAKkB,IAAL,CAAUJ,SAAV,KAAwBZ,OAAOF,KAAKiB,GAAL,CAASH,SAAT,CAA/B,CAD4B,GAEpCnB,QAAQmB,SAFO,EAEIZ,IAFJ,CAAnB;;EAIA,IAAI,CAACa,MAAMnB,GAAN,CAAL,EAAiB;IACf,IAAIoB,eAAepB,GAAnB,EACEoB,eAAepB,GAAf,CADF,KAEO,IAAI,CAACmB,MAAMjB,GAAN,CAAD,IAAekB,eAAelB,GAAlC,EACLkB,eAAepB,MAAMI,KAAKmB,KAAL,CAAWlB,0CAAqB,CAACH,MAAMF,GAAP,IAAcM,IAAnC,EAAyCA,IAAzC,CAAX,IAA6DA,IAAlF;EAEJ,CANA,MAMO,IAAI,CAACa,MAAMjB,GAAN,CAAD,IAAekB,eAAelB,GAAlC,EACLkB,eAAehB,KAAKmB,KAAL,CAAWlB,0CAAqBH,MAAMI,IAA3B,EAAiCA,IAAjC,CAAX,IAAqDA,IAApE,CAfyG,CAkB3G;;;EACAc,eAAef,0CAAqBe,YAArB,EAAmCd,IAAnC,CAAf;EAEA,OAAOc,YAAP;AACF;;AAGO,SAASI,wCAAT,CAAuBzB,KAAvB,EAAsC0B,MAAtC,EAAuE;EAAA,IAAjBC,IAAiB,uEAAF,EAAE;EAC5E,MAAMZ,MAAMV,KAAKU,GAAL,CAASY,IAAT,EAAeD,MAAf,CAAZ;EAEA,OAAOrB,KAAKW,KAAL,CAAWhB,QAAQe,GAAnB,IAA0BA,GAAjC;AACF","names":["$9446cca9a3875146$export$7d15b64cf5a3a4c4","value","min","Infinity","max","newValue","Math","$9446cca9a3875146$export$e1a7b8e69ef6c52f","step","roundedValue","stepString","toString","pointIndex","indexOf","precision","length","pow","round","$9446cca9a3875146$export$cb6e0bb50bc19463","Number","remainder","isNaN","snappedValue","abs","sign","floor","$9446cca9a3875146$export$b6268554fba451f","digits","base"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-stately\\utils\\dist\\packages\\@react-stately\\utils\\src\\number.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n/**\n * Takes a value and forces it to the closest min/max if it's outside. Also forces it to the closest valid step.\n */\nexport function clamp(value: number, min: number = -Infinity, max: number = Infinity): number {\n  let newValue = Math.min(Math.max(value, min), max);\n  return newValue;\n}\n\nexport function roundToStepPrecision(value: number, step: number): number {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf('.');\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n  return roundedValue;\n}\n\nexport function snapValueToStep(value: number, min: number | undefined, max: number | undefined, step: number): number {\n  min = Number(min);\n  max = Number(max);\n  let remainder = ((value - (isNaN(min) ? 0 : min)) % step);\n  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step\n    ? value + Math.sign(remainder) * (step - Math.abs(remainder))\n    : value - remainder, step);\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step;\n  }\n\n  // correct floating point behavior by rounding to step precision\n  snappedValue = roundToStepPrecision(snappedValue, step);\n\n  return snappedValue;\n}\n\n/* Takes a value and rounds off to the number of digits. */\nexport function toFixedNumber(value: number, digits: number, base: number = 10): number {\n  const pow = Math.pow(base, digits);\n\n  return Math.round(value * pow) / pow;\n}\n"]},"metadata":{},"sourceType":"module"}
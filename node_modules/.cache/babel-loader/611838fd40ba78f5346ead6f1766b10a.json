{"ast":null,"code":"import { useEffectEvent as $ispOf$useEffectEvent, getOwnerDocument as $ispOf$getOwnerDocument } from \"@react-aria/utils\";\nimport { useRef as $ispOf$useRef, useEffect as $ispOf$useEffect } from \"react\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n  let {\n    ref: ref,\n    onInteractOutside: onInteractOutside,\n    isDisabled: isDisabled,\n    onInteractOutsideStart: onInteractOutsideStart\n  } = props;\n  let stateRef = (0, $ispOf$useRef)({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n  let onPointerDown = (0, $ispOf$useEffectEvent)(e => {\n    if (onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) onInteractOutsideStart(e);\n      stateRef.current.isPointerDown = true;\n    }\n  });\n  let triggerInteractOutside = (0, $ispOf$useEffectEvent)(e => {\n    if (onInteractOutside) onInteractOutside(e);\n  });\n  (0, $ispOf$useEffect)(() => {\n    let state = stateRef.current;\n    if (isDisabled) return;\n    const element = ref.current;\n    const documentObject = (0, $ispOf$getOwnerDocument)(element); // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n\n    if (typeof PointerEvent !== 'undefined') {\n      let onClick = e => {\n        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      }; // changing these to capture phase fixed combobox\n      // Use click instead of pointerup to avoid Android Chrome issue\n      // https://issues.chromium.org/issues/40732224\n\n\n      documentObject.addEventListener('pointerdown', onPointerDown, true);\n      documentObject.addEventListener('click', onClick, true);\n      return () => {\n        documentObject.removeEventListener('pointerdown', onPointerDown, true);\n        documentObject.removeEventListener('click', onClick, true);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      let onMouseUp = e => {\n        if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;else if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n\n      let onTouchEnd = e => {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n\n      documentObject.addEventListener('mousedown', onPointerDown, true);\n      documentObject.addEventListener('mouseup', onMouseUp, true);\n      documentObject.addEventListener('touchstart', onPointerDown, true);\n      documentObject.addEventListener('touchend', onTouchEnd, true);\n      return () => {\n        documentObject.removeEventListener('mousedown', onPointerDown, true);\n        documentObject.removeEventListener('mouseup', onMouseUp, true);\n        documentObject.removeEventListener('touchstart', onPointerDown, true);\n        documentObject.removeEventListener('touchend', onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\n\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n  if (event.button > 0) return false;\n\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    const ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false; // If the target is within a top layer element (e.g. toasts), ignore.\n\n    if (event.target.closest('[data-react-aria-top-layer]')) return false;\n  }\n\n  if (!ref.current) return false; // When the event source is inside a Shadow DOM, event.target is just the shadow root.\n  // Using event.composedPath instead means we can get the actual element inside the shadow root.\n  // This only works if the shadow root is open, there is no way to detect if it is closed.\n  // If the event composed path contains the ref, interaction is inside.\n\n  return !event.composedPath().includes(ref.current);\n}\n\nexport { $e0b6e0b68ec7f50f$export$872b660ac5a1ff98 as useInteractOutside };","map":{"version":3,"mappings":"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","names":["$e0b6e0b68ec7f50f$export$872b660ac5a1ff98","props","ref","onInteractOutside","isDisabled","onInteractOutsideStart","stateRef","isPointerDown","ignoreEmulatedMouseEvents","onPointerDown","e","$e0b6e0b68ec7f50f$var$isValidEvent","current","triggerInteractOutside","state","element","documentObject","PointerEvent","onClick","addEventListener","removeEventListener","process","env","NODE_ENV","onMouseUp","onTouchEnd","event","button","target","ownerDocument","documentElement","contains","closest","composedPath","includes"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\interactions\\dist\\packages\\@react-aria\\interactions\\src\\useInteractOutside.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nimport {getOwnerDocument, useEffectEvent} from '@react-aria/utils';\nimport {RefObject} from '@react-types/shared';\nimport {useEffect, useRef} from 'react';\n\nexport interface InteractOutsideProps {\n  ref: RefObject<Element | null>,\n  onInteractOutside?: (e: PointerEvent) => void,\n  onInteractOutsideStart?: (e: PointerEvent) => void,\n  /** Whether the interact outside events should be disabled. */\n  isDisabled?: boolean\n}\n\n/**\n * Example, used in components like Dialogs and Popovers so they can close\n * when a user clicks outside them.\n */\nexport function useInteractOutside(props: InteractOutsideProps): void {\n  let {ref, onInteractOutside, isDisabled, onInteractOutsideStart} = props;\n  let stateRef = useRef({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n\n  let onPointerDown = useEffectEvent((e) => {\n    if (onInteractOutside && isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) {\n        onInteractOutsideStart(e);\n      }\n      stateRef.current.isPointerDown = true;\n    }\n  });\n\n  let triggerInteractOutside = useEffectEvent((e: PointerEvent) => {\n    if (onInteractOutside) {\n      onInteractOutside(e);\n    }\n  });\n\n  useEffect(() => {\n    let state = stateRef.current;\n    if (isDisabled) {\n      return;\n    }\n\n    const element = ref.current;\n    const documentObject = getOwnerDocument(element);\n\n    // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n    if (typeof PointerEvent !== 'undefined') {\n      let onClick = (e) => {\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      // changing these to capture phase fixed combobox\n      // Use click instead of pointerup to avoid Android Chrome issue\n      // https://issues.chromium.org/issues/40732224\n      documentObject.addEventListener('pointerdown', onPointerDown, true);\n      documentObject.addEventListener('click', onClick, true);\n\n      return () => {\n        documentObject.removeEventListener('pointerdown', onPointerDown, true);\n        documentObject.removeEventListener('click', onClick, true);\n      };\n    } else if (process.env.NODE_ENV === 'test') {\n      let onMouseUp = (e) => {\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n        } else if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      let onTouchEnd = (e) => {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && isValidEvent(e, ref)) {\n          triggerInteractOutside(e);\n        }\n        state.isPointerDown = false;\n      };\n\n      documentObject.addEventListener('mousedown', onPointerDown, true);\n      documentObject.addEventListener('mouseup', onMouseUp, true);\n      documentObject.addEventListener('touchstart', onPointerDown, true);\n      documentObject.addEventListener('touchend', onTouchEnd, true);\n\n      return () => {\n        documentObject.removeEventListener('mousedown', onPointerDown, true);\n        documentObject.removeEventListener('mouseup', onMouseUp, true);\n        documentObject.removeEventListener('touchstart', onPointerDown, true);\n        documentObject.removeEventListener('touchend', onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\n\nfunction isValidEvent(event, ref) {\n  if (event.button > 0) {\n    return false;\n  }\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    const ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) {\n      return false;\n    }\n    // If the target is within a top layer element (e.g. toasts), ignore.\n    if (event.target.closest('[data-react-aria-top-layer]')) {\n      return false;\n    }\n  }\n\n  if (!ref.current) {\n    return false;\n  }\n\n  // When the event source is inside a Shadow DOM, event.target is just the shadow root.\n  // Using event.composedPath instead means we can get the actual element inside the shadow root.\n  // This only works if the shadow root is open, there is no way to detect if it is closed.\n  // If the event composed path contains the ref, interaction is inside.\n  return !event.composedPath().includes(ref.current);\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\n\nconst getRect = element => {\n  const {\n    offsetWidth,\n    offsetHeight\n  } = element;\n  return {\n    width: offsetWidth,\n    height: offsetHeight\n  };\n};\n\nconst defaultKeyExtractor = index => index;\n\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n\n  if (!element) {\n    return;\n  }\n\n  const targetWindow = instance.targetWindow;\n\n  if (!targetWindow) {\n    return;\n  }\n\n  const handler = rect => {\n    const {\n      width,\n      height\n    } = rect;\n    cb({\n      width: Math.round(width),\n      height: Math.round(height)\n    });\n  };\n\n  handler(getRect(element));\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {};\n  }\n\n  const observer = new targetWindow.ResizeObserver(entries => {\n    const run = () => {\n      const entry = entries[0];\n\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n\n        if (box) {\n          handler({\n            width: box.inlineSize,\n            height: box.blockSize\n          });\n          return;\n        }\n      }\n\n      handler(getRect(element));\n    };\n\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, {\n    box: \"border-box\"\n  });\n  return () => {\n    observer.unobserve(element);\n  };\n};\n\nconst addEventListenerOptions = {\n  passive: true\n};\n\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n\n  if (!element) {\n    return;\n  }\n\n  const handler = () => {\n    cb({\n      width: element.innerWidth,\n      height: element.innerHeight\n    });\n  };\n\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\n\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\n\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n\n  if (!element) {\n    return;\n  }\n\n  const targetWindow = instance.targetWindow;\n\n  if (!targetWindow) {\n    return;\n  }\n\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(targetWindow, () => {\n    cb(offset, false);\n  }, instance.options.isScrollingResetDelay);\n\n  const createHandler = isScrolling => () => {\n    const {\n      horizontal,\n      isRtl\n    } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\n\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n\n  if (!element) {\n    return;\n  }\n\n  const targetWindow = instance.targetWindow;\n\n  if (!targetWindow) {\n    return;\n  }\n\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(targetWindow, () => {\n    cb(offset, false);\n  }, instance.options.isScrollingResetDelay);\n\n  const createHandler = isScrolling => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\n\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n\n    if (box) {\n      const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n      return size;\n    }\n  }\n\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\n\nconst windowScroll = (offset, _ref, instance) => {\n  let {\n    adjustments = 0,\n    behavior\n  } = _ref;\n\n  var _a, _b;\n\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\n\nconst elementScroll = (offset, _ref2, instance) => {\n  let {\n    adjustments = 0,\n    behavior\n  } = _ref2;\n\n  var _a, _b;\n\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\n\nclass Virtualizer {\n  constructor(opts) {\n    var _this = this;\n\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */new Map();\n\n    this.observer = /* @__PURE__ */(() => {\n      let _ro = null;\n\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n\n        return _ro = new this.targetWindow.ResizeObserver(entries => {\n          entries.forEach(entry => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n\n      return {\n        disconnect: () => {\n          var _a;\n\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: target => {\n          var _a;\n\n          return (_a = get()) == null ? void 0 : _a.observe(target, {\n            box: \"border-box\"\n          });\n        },\n        unobserve: target => {\n          var _a;\n\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n\n    this.range = null;\n\n    this.setOptions = opts2 => {\n      Object.entries(opts2).forEach(_ref3 => {\n        let [key, value] = _ref3;\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n\n    this.notify = sync => {\n      var _a, _b;\n\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n\n    this.maybeNotify = memo(() => {\n      this.calculateRange();\n      return [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null];\n    }, isScrolling => {\n      this.notify(isScrolling);\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n      debug: () => this.options.debug,\n      initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]\n    });\n\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n\n    this._willUpdate = () => {\n      var _a;\n\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n\n        this.scrollElement = scrollElement;\n\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n\n        this.elementsCache.forEach(cached => {\n          this.observer.observe(cached);\n        });\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.maybeNotify();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0;\n          this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n          this.scrollOffset = offset;\n          this.isScrolling = isScrolling;\n          this.maybeNotify();\n        }));\n      }\n    };\n\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */new Map();\n      const furthestMeasurements = /* @__PURE__ */new Map();\n\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n\n        const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n\n    this.getMeasurementOptions = memo(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey, this.options.enabled], (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = [];\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled\n      };\n    }, {\n      key: false\n    });\n    this.getMeasurements = memo(() => [this.getMeasurementOptions(), this.itemSizeCache], (_ref4, itemSizeCache) => {\n      let {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled\n      } = _ref4;\n\n      if (!enabled) {\n        this.measurementsCache = [];\n        this.itemSizeCache.clear();\n        return [];\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache;\n        this.measurementsCache.forEach(item => {\n          this.itemSizeCache.set(item.key, item.size);\n        });\n      }\n\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n        const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n        const measuredSize = itemSizeCache.get(key);\n        const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane\n        };\n      }\n\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.getScrollOffset(), this.options.lanes], (measurements, outerSize, scrollOffset, lanes) => {\n      return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset,\n        lanes\n      }) : null;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n      debug: () => this.options.debug\n    });\n    this.getVirtualIndexes = memo(() => {\n      let startIndex = null;\n      let endIndex = null;\n      const range = this.calculateRange();\n\n      if (range) {\n        startIndex = range.startIndex;\n        endIndex = range.endIndex;\n      }\n\n      this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n      return [this.options.rangeExtractor, this.options.overscan, this.options.count, startIndex, endIndex];\n    }, (rangeExtractor, overscan, count, startIndex, endIndex) => {\n      return startIndex === null || endIndex === null ? [] : rangeExtractor({\n        startIndex,\n        endIndex,\n        overscan,\n        count\n      });\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n      debug: () => this.options.debug\n    });\n\n    this.indexFromElement = node => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n\n      if (!indexStr) {\n        console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n        return -1;\n      }\n\n      return parseInt(indexStr, 10);\n    };\n\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n\n      if (!item) {\n        return;\n      }\n\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n\n      if (!item) {\n        return;\n      }\n\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : this.scrollDirection === \"backward\" && item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n\n    this.measureElement = node => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n\n      this._measureElement(node, void 0);\n    };\n\n    this.getVirtualItems = memo(() => [this.getVirtualIndexes(), this.getMeasurements()], (indexes, measurements) => {\n      const virtualItems = [];\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k];\n        const measurement = measurements[i];\n        virtualItems.push(measurement);\n      }\n\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n      debug: () => this.options.debug\n    });\n\n    this.getVirtualItemForOffset = offset => {\n      const measurements = this.getMeasurements();\n\n      if (measurements.length === 0) {\n        return void 0;\n      }\n\n      return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, index => notUndefined(measurements[index]).start, offset)]);\n    };\n\n    this.getOffsetForAlignment = function (toOffset, align) {\n      let itemSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      const size = _this.getSize();\n\n      const scrollOffset = _this.getScrollOffset();\n\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n\n      const maxOffset = _this.getTotalSize() - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n\n    this.getOffsetForIndex = function (index) {\n      let align = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n      index = Math.max(0, Math.min(index, _this.options.count - 1));\n      const item = _this.measurementsCache[index];\n\n      if (!item) {\n        return void 0;\n      }\n\n      const size = _this.getSize();\n\n      const scrollOffset = _this.getScrollOffset();\n\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - _this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + _this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n\n      const toOffset = align === \"end\" ? item.end + _this.options.scrollPaddingEnd : item.start - _this.options.scrollPaddingStart;\n      return [_this.getOffsetForAlignment(toOffset, align, item.size), align];\n    };\n\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n\n    this.scrollToOffset = function (toOffset) {\n      let {\n        align = \"start\",\n        behavior\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _this.cancelScrollToIndex();\n\n      if (behavior === \"smooth\" && _this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n\n      _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n\n    this.scrollToIndex = function (index) {\n      let {\n        align: initialAlign = \"auto\",\n        behavior\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      index = Math.max(0, Math.min(index, _this.options.count - 1));\n\n      _this.cancelScrollToIndex();\n\n      if (behavior === \"smooth\" && _this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n\n      const offsetAndAlign = _this.getOffsetForIndex(index, initialAlign);\n\n      if (!offsetAndAlign) return;\n      const [offset, align] = offsetAndAlign;\n\n      _this._scrollToOffset(offset, {\n        adjustments: void 0,\n        behavior\n      });\n\n      if (behavior !== \"smooth\" && _this.isDynamicMode() && _this.targetWindow) {\n        _this.scrollToIndexTimeoutId = _this.targetWindow.setTimeout(() => {\n          _this.scrollToIndexTimeoutId = null;\n\n          const elementInDOM = _this.elementsCache.has(_this.options.getItemKey(index));\n\n          if (elementInDOM) {\n            const result = _this.getOffsetForIndex(index, align);\n\n            if (!result) return;\n            const [latestOffset] = result;\n\n            const currentScrollOffset = _this.getScrollOffset();\n\n            if (!approxEqual(latestOffset, currentScrollOffset)) {\n              _this.scrollToIndex(index, {\n                align,\n                behavior\n              });\n            }\n          } else {\n            _this.scrollToIndex(index, {\n              align,\n              behavior\n            });\n          }\n        });\n      }\n    };\n\n    this.scrollBy = function (delta) {\n      let {\n        behavior\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _this.cancelScrollToIndex();\n\n      if (behavior === \"smooth\" && _this.isDynamicMode()) {\n        console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n      }\n\n      _this._scrollToOffset(_this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n\n    this.getTotalSize = () => {\n      var _a;\n\n      const measurements = this.getMeasurements();\n      let end;\n\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n\n        while (endIndex >= 0 && endByLane.some(val => val === null)) {\n          const item = measurements[endIndex];\n\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n\n          endIndex--;\n        }\n\n        end = Math.max(...endByLane.filter(val => val !== null));\n      }\n\n      return Math.max(end - this.options.scrollMargin + this.options.paddingEnd, 0);\n    };\n\n    this._scrollToOffset = (offset, _ref5) => {\n      let {\n        adjustments,\n        behavior\n      } = _ref5;\n      this.options.scrollToFn(offset, {\n        behavior,\n        adjustments\n      }, this);\n    };\n\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */new Map();\n      this.notify(false);\n    };\n\n    this.setOptions(opts);\n  }\n\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref6) {\n  let {\n    measurements,\n    outerSize,\n    scrollOffset,\n    lanes\n  } = _ref6;\n  const lastIndex = measurements.length - 1;\n\n  const getOffset = index => measurements[index].start;\n\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n\n  let startIndex = findNearestBinarySearch(0, lastIndex, getOffset, scrollOffset);\n  let endIndex = startIndex;\n\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n\n    while (endIndex < lastIndex && endPerLane.some(pos => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n\n    while (startIndex >= 0 && startPerLane.some(pos => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n\n  return {\n    startIndex,\n    endIndex\n  };\n}\n\nexport { Virtualizer, approxEqual, debounce, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, notUndefined, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };","map":{"version":3,"mappings":"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","names":["getRect","element","offsetWidth","offsetHeight","width","height","index","range","start","Math","max","startIndex","overscan","min","endIndex","count","arr","i","end","push","instance","cb","scrollElement","targetWindow","rect","round","handler","ResizeObserver","observer","entries","run","entry","borderBoxSize","box","inlineSize","blockSize","options","useAnimationFrameWithResizeObserver","requestAnimationFrame","observe","unobserve","addEventListenerOptions","passive","innerWidth","innerHeight","supportsScrollend","window","offset","fallback","useScrollendEvent","debounce","isScrollingResetDelay","isScrolling","horizontal","isRtl","createHandler","endHandler","registerScrollendEvent","measureElement","size","adjustments","behavior","toOffset","scrollTo","Virtualizer","constructor","opts","unsubs","scrollToIndexTimeoutId","Map","pendingMeasuredCacheIndexes","scrollAdjustments","_ro","get","target","disconnect","Object","forEach","key","value","debug","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","defaultKeyExtractor","rangeExtractor","defaultRangeExtractor","onChange","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","sync","maybeNotify","memo","calculateRange","notify","process","env","NODE_ENV","initialDeps","cleanup","filter","Boolean","d","getScrollElement","ownerDocument","defaultView","_a","cached","getScrollOffset","observeElementRect","scrollRect","observeElementOffset","scrollDirection","scrollOffset","getSize","measurements","m","furthestMeasurementsFound","has","measurement","lane","previousFurthestMeasurement","furthestMeasurements","Array","from","values","sort","a","b","getMeasurementOptions","getMeasurements","itemSizeCache","measurementsCache","clear","length","item","set","slice","furthestMeasurement","getFurthestMeasurement","measuredSize","estimateSize","outerSize","updateDeps","node","getAttribute","attributeName","indexStr","console","indexFromElement","prevNode","elementsCache","isConnected","itemSize","delta","shouldAdjustScrollPositionOnItemSizeChange","delete","getVirtualIndexes","indexes","virtualItems","k","len","findNearestBinarySearch","notUndefined","align","getTotalSize","maxOffset","getOffsetForAlignment","isDynamicMode","cancelScrollToIndex","clearTimeout","_scrollToOffset","initialAlign","offsetAndAlign","getOffsetForIndex","setTimeout","elementInDOM","result","latestOffset","approxEqual","currentScrollOffset","scrollToIndex","endByLane","fill","some","val","scrollToFn","setOptions","low","high","getCurrentValue","middle","currentValue","getOffset","lastIndex","endPerLane","pos","startPerLane"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@tanstack\\virtual-core\\src\\index.ts"],"sourcesContent":["import { approxEqual, debounce, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string | bigint\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\nexport interface Rect {\n  width: number\n  height: number\n}\n\n//\n\nconst getRect = (element: HTMLElement): Rect => {\n  const { offsetWidth, offsetHeight } = element\n  return { width: offsetWidth, height: offsetHeight }\n}\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(getRect(element as unknown as HTMLElement))\n\n  if (!targetWindow.ResizeObserver) {\n    return () => {}\n  }\n\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0]\n      if (entry?.borderBoxSize) {\n        const box = entry.borderBoxSize[0]\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize })\n          return\n        }\n      }\n      handler(getRect(element as unknown as HTMLElement))\n    }\n\n    instance.options.useAnimationFrameWithResizeObserver\n      ? requestAnimationFrame(run)\n      : run()\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nconst addEventListenerOptions = {\n  passive: true,\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, addEventListenerOptions)\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nconst supportsScrollend =\n  typeof window == 'undefined' ? true : 'onscrollend' in window\n\ntype ObserveOffsetCallBack = (offset: number, isScrolling: boolean) => void\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    const { horizontal, isRtl } = instance.options\n    offset = horizontal\n      ? element['scrollLeft'] * ((isRtl && -1) || 1)\n      : element['scrollTop']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: ObserveOffsetCallBack,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n  const targetWindow = instance.targetWindow\n  if (!targetWindow) {\n    return\n  }\n\n  let offset = 0\n  const fallback =\n    instance.options.useScrollendEvent && supportsScrollend\n      ? () => undefined\n      : debounce(\n          targetWindow,\n          () => {\n            cb(offset, false)\n          },\n          instance.options.isScrollingResetDelay,\n        )\n\n  const createHandler = (isScrolling: boolean) => () => {\n    offset = element[instance.options.horizontal ? 'scrollX' : 'scrollY']\n    fallback()\n    cb(offset, isScrolling)\n  }\n  const handler = createHandler(true)\n  const endHandler = createHandler(false)\n  endHandler()\n\n  element.addEventListener('scroll', handler, addEventListenerOptions)\n  const registerScrollendEvent =\n    instance.options.useScrollendEvent && supportsScrollend\n  if (registerScrollendEvent) {\n    element.addEventListener('scrollend', endHandler, addEventListenerOptions)\n  }\n  return () => {\n    element.removeEventListener('scroll', handler)\n    if (registerScrollendEvent) {\n      element.removeEventListener('scrollend', endHandler)\n    }\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n\n  return (element as unknown as HTMLElement)[\n    instance.options.horizontal ? 'offsetWidth' : 'offsetHeight'\n  ]\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: ObserveOffsetCallBack,\n  ) => void | (() => void)\n  // Optional\n  debug?: boolean\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number | (() => number)\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => Array<number>\n  scrollMargin?: number\n  gap?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: Array<VirtualItem>\n  lanes?: number\n  isScrollingResetDelay?: number\n  useScrollendEvent?: boolean\n  enabled?: boolean\n  isRtl?: boolean\n  useAnimationFrameWithResizeObserver?: boolean\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: Array<void | (() => void)> = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  targetWindow: (Window & typeof globalThis) | null = null\n  isScrolling = false\n  private scrollToIndexTimeoutId: number | null = null\n  measurementsCache: Array<VirtualItem> = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: Array<number> = []\n  scrollRect: Rect | null = null\n  scrollOffset: number | null = null\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments = 0\n  shouldAdjustScrollPositionOnItemSizeChange:\n    | undefined\n    | ((\n        item: VirtualItem,\n        delta: number,\n        instance: Virtualizer<TScrollElement, TItemElement>,\n      ) => boolean)\n  elementsCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      }\n\n      if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n        return null\n      }\n\n      return (_ro = new this.targetWindow.ResizeObserver((entries) => {\n        entries.forEach((entry) => {\n          const run = () => {\n            this._measureElement(entry.target as TItemElement, entry)\n          }\n          this.options.useAnimationFrameWithResizeObserver\n            ? requestAnimationFrame(run)\n            : run()\n        })\n      }))\n    }\n\n    return {\n      disconnect: () => {\n        get()?.disconnect()\n        _ro = null\n      },\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      gap: 0,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      isScrollingResetDelay: 150,\n      enabled: true,\n      isRtl: false,\n      useScrollendEvent: false,\n      useAnimationFrameWithResizeObserver: false,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.observer.disconnect()\n    this.scrollElement = null\n    this.targetWindow = null\n  }\n\n  _didMount = () => {\n    return () => {\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.enabled\n      ? this.options.getScrollElement()\n      : null\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      if (!scrollElement) {\n        this.maybeNotify()\n        return\n      }\n\n      this.scrollElement = scrollElement\n\n      if (this.scrollElement && 'ownerDocument' in this.scrollElement) {\n        this.targetWindow = this.scrollElement.ownerDocument.defaultView\n      } else {\n        this.targetWindow = this.scrollElement?.window ?? null\n      }\n\n      this.elementsCache.forEach((cached) => {\n        this.observer.observe(cached)\n      })\n\n      this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset, isScrolling) => {\n          this.scrollAdjustments = 0\n          this.scrollDirection = isScrolling\n            ? this.getScrollOffset() < offset\n              ? 'forward'\n              : 'backward'\n            : null\n          this.scrollOffset = offset\n          this.isScrolling = isScrolling\n\n          this.maybeNotify()\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    if (!this.options.enabled) {\n      this.scrollRect = null\n      return 0\n    }\n\n    this.scrollRect = this.scrollRect ?? this.options.initialRect\n\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private getScrollOffset = () => {\n    if (!this.options.enabled) {\n      this.scrollOffset = null\n      return 0\n    }\n\n    this.scrollOffset =\n      this.scrollOffset ??\n      (typeof this.options.initialOffset === 'function'\n        ? this.options.initialOffset()\n        : this.options.initialOffset)\n\n    return this.scrollOffset\n  }\n\n  private getFurthestMeasurement = (\n    measurements: Array<VirtualItem>,\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n          if (a.end === b.end) {\n            return a.index - b.index\n          }\n\n          return a.end - b.end\n        })[0]\n      : undefined\n  }\n\n  private getMeasurementOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n      this.options.enabled,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n        enabled,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getMeasurements = memo(\n    () => [this.getMeasurementOptions(), this.itemSizeCache],\n    (\n      { count, paddingStart, scrollMargin, getItemKey, enabled },\n      itemSizeCache,\n    ) => {\n      if (!enabled) {\n        this.measurementsCache = []\n        this.itemSizeCache.clear()\n        return []\n      }\n\n      if (this.measurementsCache.length === 0) {\n        this.measurementsCache = this.options.initialMeasurementsCache\n        this.measurementsCache.forEach((item) => {\n          this.itemSizeCache.set(item.key, item.size)\n        })\n      }\n\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end + this.options.gap\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [\n      this.getMeasurements(),\n      this.getSize(),\n      this.getScrollOffset(),\n      this.options.lanes,\n    ],\n    (measurements, outerSize, scrollOffset, lanes) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n              lanes,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualIndexes = memo(\n    () => {\n      let startIndex: number | null = null\n      let endIndex: number | null = null\n      const range = this.calculateRange()\n      if (range) {\n        startIndex = range.startIndex\n        endIndex = range.endIndex\n      }\n      this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex])\n      return [\n        this.options.rangeExtractor,\n        this.options.overscan,\n        this.options.count,\n        startIndex,\n        endIndex,\n      ]\n    },\n    (rangeExtractor, overscan, count, startIndex, endIndex) => {\n      return startIndex === null || endIndex === null\n        ? []\n        : rangeExtractor({\n            startIndex,\n            endIndex,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const index = this.indexFromElement(node)\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const key = item.key\n    const prevNode = this.elementsCache.get(key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.elementsCache.set(key, node)\n    }\n\n    if (node.isConnected) {\n      this.resizeItem(index, this.options.measureElement(node, entry, this))\n    }\n  }\n\n  resizeItem = (index: number, size: number) => {\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return\n    }\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (\n        this.shouldAdjustScrollPositionOnItemSizeChange !== undefined\n          ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this)\n          : this.scrollDirection === 'backward' &&\n            item.start < this.getScrollOffset() + this.scrollAdjustments\n      ) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null | undefined) => {\n    if (!node) {\n      this.elementsCache.forEach((cached, key) => {\n        if (!cached.isConnected) {\n          this.observer.unobserve(cached)\n          this.elementsCache.delete(key)\n        }\n      })\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getVirtualIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: Array<VirtualItem> = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getVirtualItems',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n    if (measurements.length === 0) {\n      return undefined\n    }\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (\n    toOffset: number,\n    align: ScrollAlignment,\n    itemSize = 0,\n  ) => {\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      align = toOffset >= scrollOffset + size ? 'end' : 'start'\n    }\n\n    if (align === 'center') {\n      // When aligning to a particular item (e.g. with scrollToIndex),\n      // adjust offset by the size of the item to center on the item\n      toOffset += (itemSize - size) / 2\n    } else if (align === 'end') {\n      toOffset -= size\n    }\n\n    const maxOffset = this.getTotalSize() - size\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const item = this.measurementsCache[index]\n    if (!item) {\n      return undefined\n    }\n\n    const size = this.getSize()\n    const scrollOffset = this.getScrollOffset()\n\n    if (align === 'auto') {\n      if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n        align = 'end'\n      } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n        align = 'start'\n      } else {\n        return [scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? item.end + this.options.scrollPaddingEnd\n        : item.start - this.options.scrollPaddingStart\n\n    return [\n      this.getOffsetForAlignment(toOffset, align, item.size),\n      align,\n    ] as const\n  }\n\n  private isDynamicMode = () => this.elementsCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n      this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const offsetAndAlign = this.getOffsetForIndex(index, initialAlign)\n    if (!offsetAndAlign) return\n\n    const [offset, align] = offsetAndAlign\n\n    this._scrollToOffset(offset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode() && this.targetWindow) {\n      this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.elementsCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const result = this.getOffsetForIndex(index, align)\n          if (!result) return\n          const [latestOffset] = result\n\n          const currentScrollOffset = this.getScrollOffset()\n          if (!approxEqual(latestOffset, currentScrollOffset)) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getScrollOffset() + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () => {\n    const measurements = this.getMeasurements()\n\n    let end: number\n    // If there are no measurements, set the end to paddingStart\n    // If there is only one lane, use the last measurement's end\n    // Otherwise find the maximum end value among all measurements\n    if (measurements.length === 0) {\n      end = this.options.paddingStart\n    } else if (this.options.lanes === 1) {\n      end = measurements[measurements.length - 1]?.end ?? 0\n    } else {\n      const endByLane = Array<number | null>(this.options.lanes).fill(null)\n      let endIndex = measurements.length - 1\n      while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n        const item = measurements[endIndex]!\n        if (endByLane[item.lane] === null) {\n          endByLane[item.lane] = item.end\n        }\n\n        endIndex--\n      }\n\n      end = Math.max(...endByLane.filter((val): val is number => val !== null))\n    }\n\n    return Math.max(\n      end - this.options.scrollMargin + this.options.paddingEnd,\n      0,\n    )\n  }\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes,\n}: {\n  measurements: Array<VirtualItem>\n  outerSize: number\n  scrollOffset: number\n  lanes: number\n}) {\n  const lastIndex = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  // handle case when item count is less than or equal to lanes\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex,\n    }\n  }\n\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset,\n  )\n  let endIndex = startIndex\n\n  if (lanes === 1) {\n    while (\n      endIndex < lastIndex &&\n      measurements[endIndex]!.end < scrollOffset + outerSize\n    ) {\n      endIndex++\n    }\n  } else if (lanes > 1) {\n    // Expand forward until we include the visible items from all lanes\n    // which are closer to the end of the virtualizer window\n    const endPerLane = Array(lanes).fill(0)\n    while (\n      endIndex < lastIndex &&\n      endPerLane.some((pos) => pos < scrollOffset + outerSize)\n    ) {\n      const item = measurements[endIndex]!\n      endPerLane[item.lane] = item.end\n      endIndex++\n    }\n\n    // Expand backward until we include all lanes' visible items\n    // closer to the top\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize)\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex]!\n      startPerLane[item.lane] = item.start\n      startIndex--\n    }\n\n    // Align startIndex to the beginning of its lane\n    startIndex = Math.max(0, startIndex - (startIndex % lanes))\n    // Align endIndex to the end of its lane\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - (endIndex % lanes)))\n  }\n\n  return { startIndex, endIndex }\n}\n"]},"metadata":{},"sourceType":"module"}
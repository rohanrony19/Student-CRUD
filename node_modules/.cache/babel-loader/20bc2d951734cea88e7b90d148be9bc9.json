{"ast":null,"code":"import { chain as $ff5963eb1fccf552$export$e08e3b67e392101e } from \"./chain.mjs\";\nimport { mergeIds as $bdb11010cef70236$export$cd8c9cb68f842629 } from \"./useId.mjs\";\nimport $7jXr9$clsx from \"clsx\";\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $3ef42575df84b30b$export$9d1611c77c2fe928() {\n  // Start with a base clone of the first argument. This is a lot faster than starting\n  // with an empty object and adding properties as we go.\n  let result = { ...(arguments.length <= 0 ? undefined : arguments[0])\n  };\n\n  for (let i = 1; i < arguments.length; i++) {\n    let props = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n    for (let key in props) {\n      let a = result[key];\n      let b = props[key]; // Chain events\n\n      if (typeof a === 'function' && typeof b === 'function' && // This is a lot faster than a regex.\n      key[0] === 'o' && key[1] === 'n' && key.charCodeAt(2) >=\n      /* 'A' */\n      65 && key.charCodeAt(2) <=\n      /* 'Z' */\n      90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e)(a, b);else if ((key === 'className' || key === 'UNSAFE_className') && typeof a === 'string' && typeof b === 'string') result[key] = (0, $7jXr9$clsx)(a, b);else if (key === 'id' && a && b) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f842629)(a, b);else result[key] = b !== undefined ? b : a;\n    }\n  }\n\n  return result;\n}\n\nexport { $3ef42575df84b30b$export$9d1611c77c2fe928 as mergeProps };","map":{"version":3,"mappings":";;;AAAA;;;;;;;;;;;;AAmCO,SAASA,yCAAT,GAAoD;EACzD;EACA;EACA,IAAIC,SAAgB,EAAC;EAAD,CAApB;;EACA,KAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,UAAKC,MAAzB,EAAiCD,GAAjC,EAAsC;IACpC,IAAIE,QAAaF,CAAb,4BAAaA,CAAb,yBAAaA,CAAb,CAAJ;;IACA,KAAK,IAAIG,GAAT,IAAgBD,KAAhB,EAAuB;MACrB,IAAIE,IAAIL,MAAM,CAACI,GAAD,CAAd;MACA,IAAIE,IAAIH,KAAK,CAACC,GAAD,CAAb,CAFqB,CAIrB;;MACA,IACE,OAAOC,CAAP,KAAa,UAAb,IACA,OAAOC,CAAP,KAAa,UADb,IAEA;MACAF,GAAG,CAAC,CAAD,CAAH,KAAW,GAHX,IAIAA,GAAG,CAAC,CAAD,CAAH,KAAW,GAJX,IAKAA,IAAIG,UAAJ,CAAe,CAAf;MAAqB;MAAU,EAL/B,IAMAH,IAAIG,UAAJ,CAAe,CAAf;MAAqB;MAAU,EAPjC,EASEP,MAAM,CAACI,GAAD,CAAN,GAAc,+CAAMC,CAAN,EAASC,CAAT,CAAd,CATF,KAYO,IACL,CAACF,QAAQ,WAAR,IAAuBA,QAAQ,kBAAhC,KACA,OAAOC,CAAP,KAAa,QADb,IAEA,OAAOC,CAAP,KAAa,QAHR,EAKLN,MAAM,CAACI,GAAD,CAAN,GAAc,iBAAKC,CAAL,EAAQC,CAAR,CAAd,CALK,KAMA,IAAIF,QAAQ,IAAR,IAAgBC,CAAhB,IAAqBC,CAAzB,EACLN,OAAOQ,EAAP,GAAY,+CAASH,CAAT,EAAYC,CAAZ,CAAZ,CADK,KAILN,MAAM,CAACI,GAAD,CAAN,GAAcE,MAAMG,SAAN,GAAkBH,CAAlB,GAAsBD,CAApC;IAEJ;EACF;;EAEA,OAAOL,MAAP;AACF","names":["$3ef42575df84b30b$export$9d1611c77c2fe928","result","i","length","props","key","a","b","charCodeAt","id","undefined"],"sources":["C:\\Users\\rohan\\Downloads\\crud-app-master\\crud-app-master\\node_modules\\@react-aria\\utils\\dist\\packages\\@react-aria\\utils\\src\\mergeProps.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain} from './chain';\nimport clsx from 'clsx';\nimport {mergeIds} from './useId';\n\ninterface Props {\n  [key: string]: any\n}\n\ntype PropsArg = Props | null | undefined;\n\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? NullToObject<V> : never;\ntype NullToObject<T> = T extends (null | undefined) ? {} : T;\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\n/**\n * Merges multiple props objects together. Event handlers are chained,\n * classNames are combined, and ids are deduplicated - different ids\n * will trigger a side-effect and re-render components hooked up with `useId`.\n * For all other props, the last prop object overrides all previous ones.\n * @param args - Multiple sets of props to merge together.\n */\nexport function mergeProps<T extends PropsArg[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\n  // Start with a base clone of the first argument. This is a lot faster than starting\n  // with an empty object and adding properties as we go.\n  let result: Props = {...args[0]};\n  for (let i = 1; i < args.length; i++) {\n    let props = args[i];\n    for (let key in props) {\n      let a = result[key];\n      let b = props[key];\n\n      // Chain events\n      if (\n        typeof a === 'function' &&\n        typeof b === 'function' &&\n        // This is a lot faster than a regex.\n        key[0] === 'o' &&\n        key[1] === 'n' &&\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\n        key.charCodeAt(2) <= /* 'Z' */ 90\n      ) {\n        result[key] = chain(a, b);\n\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        (key === 'className' || key === 'UNSAFE_className') &&\n        typeof a === 'string' &&\n        typeof b === 'string'\n      ) {\n        result[key] = clsx(a, b);\n      } else if (key === 'id' && a && b) {\n        result.id = mergeIds(a, b);\n        // Override others\n      } else {\n        result[key] = b !== undefined ? b : a;\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>;\n}\n"]},"metadata":{},"sourceType":"module"}